FUNCTION  <SNR>19_get()
Called 15 times
Total time:   0.000625
 Self time:   0.000625

count  total (s)   self (s)
   15              0.000039   if a:0 == 2
                                return deepcopy(get(a:2, 'delimitMate_' . a:name, a:1))
                              elseif a:0 == 1
                                let bufoptions = get(s:options, bufnr('%'), {})
                                return deepcopy(get(bufoptions, a:name, a:1))
                              else
   15              0.000256     return deepcopy(eval('s:options.' . bufnr('%') . '.' . a:name))
                              endif

FUNCTION  lfMru#record()
Called 1 time
Total time:   0.000286
 Self time:   0.000286

count  total (s)   self (s)
    1              0.000019     if a:name == '' || !filereadable(a:name)
                                    return
                                endif
    1              0.000245     let file_list = readfile(g:Lf_MruCacheFileName)
    1              0.000004     if empty(file_list)
                                    call writefile([a:name], g:Lf_MruCacheFileName)
                                elseif a:name != file_list[0]
                                    call filter(file_list, 'v:val != a:name')
                                    call writefile([a:name] + file_list, g:Lf_MruCacheFileName)
                                endif

FUNCTION  ale_linters#python#mypy#Handle()
Called 3 times
Total time:   0.002964
 Self time:   0.000117

count  total (s)   self (s)
    3   0.002788   0.000024     let l:dir = s:GetDir(a:buffer)
                                " Look for lines like the following:
                                "
                                " file.py:4: error: No library stub file for module 'django.db'
                                "
                                " Lines like these should be ignored below:
                                "
                                " file.py:4: note: (Stub files are from https://github.com/python/typeshed)
    3              0.000008     let l:pattern = '\v^([a-zA-Z]?:?[^:]+):(\d+):?(\d+)?: (error|warning): (.+)$'
    3              0.000004     let l:output = []
                            
    3   0.000108   0.000025     for l:match in ale#util#GetMatches(a:lines, l:pattern)
                                    " Skip invalid syntax errors if the option is on.
                                    if l:match[5] is# 'invalid syntax'&& ale#Var(a:buffer, 'python_mypy_ignore_invalid_syntax')
                                        continue
                                    endif
                            
                                    call add(l:output, {   'filename': ale#path#GetAbsPath(l:dir, l:match[1]),   'lnum': l:match[2] + 0,   'col': l:match[3] + 0,   'type': l:match[4] is# 'error' ? 'E' : 'W',   'text': l:match[5],})
                                endfor
                            
    3              0.000004     return l:output

FUNCTION  <SNR>131_RunLinter()
Called 4 times
Total time:   0.056589
 Self time:   0.000797

count  total (s)   self (s)
    4              0.000011     if !empty(a:linter.lsp)
                                    return ale#lsp_linter#CheckWithLSP(a:buffer, a:linter)
                                else
    4   0.014183   0.000030         let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                            
    4   0.000076   0.000021         if ale#engine#IsExecutable(a:buffer, l:executable)
    4   0.042187   0.000603             return s:InvokeChain(a:buffer, a:linter, 0, [])
                                    endif
                                endif
                            
                                return 0

FUNCTION  ale#job#IsRunning()
Called 4 times
Total time:   0.000088
 Self time:   0.000088

count  total (s)   self (s)
    4              0.000017     if has('nvim')
                                    try
                                        " In NeoVim, if the job isn't running, jobpid() will throw.
                                        call jobpid(a:job_id)
                                        return 1
                                    catch
                                    endtry
                                elseif has_key(s:job_map, a:job_id)
                                    let l:job = s:job_map[a:job_id].job
                                    return job_status(l:job) is# 'run'
                                endif
                            
    4              0.000004     return 0

FUNCTION  <SNR>68_JoinArgs()
Called 1 time
Total time:   0.000318
 Self time:   0.000201

count  total (s)   self (s)
    1              0.000002         let safeArgs = []
   14              0.000017         for arg in a:args
   13   0.000260   0.000143             let safeArgs = safeArgs + [s:SanitizeArg(arg)]
   13              0.000020         endfor
    1              0.000013         return join(safeArgs, ' ')

FUNCTION  <SNR>142_OnFileReadyToParse()
Called 3 times
Total time:   0.005813
 Self time:   0.005408

count  total (s)   self (s)
                              " Accepts an optional parameter that is either 0 or 1. If 1, send a
                              " FileReadyToParse event notification, whether the buffer has changed or not;
                              " effectively forcing a parse of the buffer. Default is 0.
    3              0.000009   let force_parsing = a:0 > 0 && a:1
                            
                              " We only want to send a new FileReadyToParse event notification if the buffer
                              " has changed since the last time we sent one, or if forced.
    3   0.000447   0.000042   if force_parsing || s:Pyeval( "ycm_state.NeedsReparse()" )
    2              0.005268     exec s:python_command "ycm_state.OnFileReadyToParse()"
                            
    2              0.000021     call timer_stop( s:pollers.file_parse_response.id )
    2              0.000027     let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
    2              0.000003   endif

FUNCTION  lfMru#recordBuffer()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000004     call add(g:Lf_MruBufnrs, a:bufNum)

FUNCTION  <SNR>111_wordcount_update()
Called 107 times
Total time:   0.005982
 Self time:   0.005982

count  total (s)   self (s)
  107              0.000428   if empty(bufname(''))
                                return
                              endif
  107              0.002006   if match(&ft, get(g:, 'airline#extensions#wordcount#filetypes')) > -1
                                let l:mode = mode()
                                if l:mode ==# 'v' || l:mode ==# 'V' || l:mode ==# 's' || l:mode ==# 'S'
                                  let b:airline_wordcount = airline#extensions#wordcount#formatters#{s:formatter}#format()
                                  let b:airline_change_tick = b:changedtick
                                else
                                  if get(b:, 'airline_wordcount_cache', '') is# '' || b:airline_wordcount_cache isnot# get(b:, 'airline_wordcount', '') || get(b:, 'airline_change_tick', 0) != b:changedtick ||  get(b:, 'airline_winwidth', 0) != winwidth(0)
                                    " cache data
                                    let b:airline_wordcount = airline#extensions#wordcount#formatters#{s:formatter}#format()
                                    let b:airline_wordcount_cache = b:airline_wordcount
                                    let b:airline_change_tick = b:changedtick
                                    let b:airline_winwidth = winwidth(0)
                                  endif
                                endif
                              endif

FUNCTION  <SNR>146_GetCounts()
Called 358 times
Total time:   0.006618
 Self time:   0.006618

count  total (s)   self (s)
  358              0.001933     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
                                    return s:CreateCountDict()
                                endif
                            
                                " Cache is cold, so manually ask for an update.
  358              0.001127     if !has_key(g:ale_buffer_info[a:buffer], 'count')
                                    call ale#statusline#Update(a:buffer, g:ale_buffer_info[a:buffer].loclist)
                                endif
                            
  358              0.000717     return g:ale_buffer_info[a:buffer].count

FUNCTION  ale#linter#Get()
Called 6 times
Total time:   0.003692
 Self time:   0.002563

count  total (s)   self (s)
    6              0.000028     let l:possibly_duplicated_linters = []
                            
                                " Handle dot-separated filetypes.
   12              0.000086     for l:original_filetype in split(a:original_filetypes, '\.')
    6   0.000635   0.000062         let l:filetype = ale#linter#ResolveFiletype(l:original_filetype)
    6   0.000226   0.000074         let l:linter_names = s:GetLinterNames(l:original_filetype)
    6   0.000466   0.000062         let l:all_linters = ale#linter#GetAll(l:filetype)
    6              0.000018         let l:filetype_linters = []
                            
    6              0.000035         if type(l:linter_names) == type('') && l:linter_names is# 'all'
                                        let l:filetype_linters = l:all_linters
                                    elseif type(l:linter_names) == type([])
                                        " Select only the linters we or the user has specified.
   48              0.000098             for l:linter in l:all_linters
   42              0.000241                 let l:name_list = [l:linter.name] + l:linter.aliases
                            
   72              0.000153                 for l:name in l:name_list
   42              0.000165                     if index(l:linter_names, l:name) >= 0
   12              0.000054                         call add(l:filetype_linters, l:linter)
   12              0.000017                         break
                                                endif
   30              0.000026                 endfor
   42              0.000051             endfor
    6              0.000012         endif
                            
    6              0.000034         call extend(l:possibly_duplicated_linters, l:filetype_linters)
    6              0.000008     endfor
                            
    6              0.000016     let l:name_list = []
    6              0.000015     let l:combined_linters = []
                            
                                " Make sure we override linters so we don't get two with the same name,
                                " like 'eslint' for both 'javascript' and 'typescript'
                                "
                                " Note that the reverse calls here modify the List variables.
   18              0.000050     for l:linter in reverse(l:possibly_duplicated_linters)
   12              0.000046         if index(l:name_list, l:linter.name) < 0
   12              0.000062             call add(l:name_list, l:linter.name)
   12              0.000039             call add(l:combined_linters, l:linter)
   12              0.000013         endif
   12              0.000011     endfor
                            
    6              0.000021     return reverse(l:combined_linters)

FUNCTION  ale#python#FindProjectRootIni()
Called 6 times
Total time:   0.004382
 Self time:   0.003406

count  total (s)   self (s)
   54   0.001372   0.000396     for l:path in ale#path#Upwards(expand('#' . a:buffer . ':p:h'))
                                    " If you change this, update ale-python-root documentation.
   48              0.002725         if filereadable(l:path . '/MANIFEST.in')|| filereadable(l:path . '/setup.cfg')|| filereadable(l:path . '/pytest.ini')|| filereadable(l:path . '/tox.ini')|| filereadable(l:path . '/mypy.ini')|| filereadable(l:path . '/pycodestyle.cfg')|| filereadable(l:path . '/flake8.cfg')
                                        return l:path
                                    endif
   48              0.000074     endfor
                            
    6              0.000007     return ''

FUNCTION  <SNR>107_is_branch_empty()
Called 179 times
Total time:   0.001061
 Self time:   0.001061

count  total (s)   self (s)
  179              0.000968   return exists('*airline#extensions#branch#head') && empty(get(b:, 'airline_head', ''))

FUNCTION  <SNR>68_IsWindows()
Called 4 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    4              0.000027         if has('win32') || has('win64')
                                        return s:true
                                    endif
    4              0.000004         return s:false

FUNCTION  ale#highlight#CreatePositions()
Called 3117 times
Total time:   0.013933
 Self time:   0.013933

count  total (s)   self (s)
 3117              0.003629     if a:line >= a:end_line
                                    " For single lines, just return the one position.
 3117              0.008119         return [[[a:line, a:col, a:end_col - a:col + 1]]]
                                endif
                            
                                " Get positions from the first line at the first column, up to a large
                                " integer for highlighting up to the end of the line, followed by
                                " the lines in-between, for highlighting entire lines, and
                                " a highlight for the last line, up to the end column.
                                let l:all_positions =   [[a:line, a:col, s:MAX_COL_SIZE]]   + range(a:line + 1, a:end_line - 1)   + [[a:end_line, 1, a:end_col]]
                            
                                return map(   range(0, len(l:all_positions) - 1, s:MAX_POS_VALUES),   'l:all_positions[v:val : v:val + s:MAX_POS_VALUES - 1]',)

FUNCTION  airline#check_mode()
Called 179 times
Total time:   0.179945
 Self time:   0.014767

count  total (s)   self (s)
  179              0.000720   let context = s:contexts[a:winnr]
                            
  179              0.000586   if get(w:, 'airline_active', 1)
  179              0.000525     let l:m = mode()
  179              0.000318     if l:m ==# "i"
  113              0.000219       let l:mode = ['insert']
  113              0.000130     elseif l:m ==# "R"
                                  let l:mode = ['replace']
                                elseif l:m =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
                                elseif l:m ==# "t"
                                  let l:mode = ['terminal']
                                else
   66              0.000588       let l:mode = ['normal']
   66              0.000050     endif
  179              0.000992     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
  179              0.000115   else
                                let l:mode = ['inactive']
                                let w:airline_current_mode = get(g:airline_mode_map, '__')
                              endif
                            
  179              0.000604   if g:airline_detect_modified && &modified
  119              0.000433     call add(l:mode, 'modified')
  119              0.000078   endif
                            
  179              0.000283   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
                              endif
                            
  179              0.000748   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
                              endif
                            
  179              0.000291   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
                              endif
                            
  179              0.000245   if &readonly || ! &modifiable
                                call add(l:mode, 'readonly')
                              endif
                            
  179              0.000734   let mode_string = join(l:mode)
  179              0.000606   if get(w:, 'airline_lastmode', '') != mode_string
    5   0.002305   0.000053     call airline#highlighter#highlight_modified_inactive(context.bufnr)
    5   0.163034   0.000108     call airline#highlighter#highlight(l:mode, context.bufnr)
    5              0.000024     let w:airline_lastmode = mode_string
    5              0.000004   endif
                            
  179              0.000163   return ''

FUNCTION  airline#util#append()
Called 1253 times
Total time:   0.010839
 Self time:   0.010839

count  total (s)   self (s)
 1253              0.002383   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
 1253              0.003115   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
 1253              0.003070   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  ale#events#QuitRecently()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000002     let l:time = getbufvar(a:buffer, 'ale_quitting', 0)
                            
    1              0.000002     return l:time && ale#events#ClockMilliseconds() - l:time < 1000

FUNCTION  <SNR>131_HandleExit()
Called 7 times
Total time:   1.095596
 Self time:   0.001249

count  total (s)   self (s)
    7              0.000025     if !has_key(s:job_info_map, a:job_id)
    3              0.000001         return
                                endif
                            
    4              0.000013     let l:job_info = s:job_info_map[a:job_id]
    4              0.000009     let l:linter = l:job_info.linter
    4              0.000006     let l:output = l:job_info.output
    4              0.000006     let l:buffer = l:job_info.buffer
    4              0.000009     let l:next_chain_index = l:job_info.next_chain_index
                            
    4              0.000008     if g:ale_history_enabled
    4   0.000229   0.000030         call ale#history#SetExitCode(l:buffer, a:job_id, a:exit_code)
    4              0.000004     endif
                            
                                " Remove this job from the list.
    4   0.000313   0.000023     call ale#job#Stop(a:job_id)
    4              0.000018     call remove(s:job_info_map, a:job_id)
    4              0.000028     call filter(g:ale_buffer_info[l:buffer].job_list, 'v:val isnot# a:job_id')
    4              0.000024     call filter(g:ale_buffer_info[l:buffer].active_linter_list, 'v:val isnot# l:linter.name')
                            
                                " Stop here if we land in the handle for a job completing if we're in
                                " a sandbox.
    4   0.000097   0.000041     if ale#util#InSandbox()
                                    return
                                endif
                            
    4              0.000022     if has('nvim') && !empty(l:output) && empty(l:output[-1])
                                    call remove(l:output, -1)
                                endif
                            
    4              0.000017     if l:next_chain_index < len(get(l:linter, 'command_chain', []))
                                    call s:InvokeChain(l:buffer, l:linter, l:next_chain_index, l:output)
                                    return
                                endif
                            
                                " Log the output of the command for ALEInfo if we should.
    4              0.000008     if g:ale_history_enabled && g:ale_history_log_output
    4   0.000694   0.000573         call ale#history#RememberOutput(l:buffer, a:job_id, l:output[:])
    4              0.000003     endif
                            
    4   0.070848   0.000073     let l:loclist = ale#util#GetFunction(l:linter.callback)(l:buffer, l:output)
                            
    4   1.023128   0.000222     call ale#engine#HandleLoclist(l:linter.name, l:buffer, l:loclist)

FUNCTION  <SNR>68_HandleActivity()
Called 108 times
Total time:   0.028354
 Self time:   0.010490

count  total (s)   self (s)
  108   0.008540   0.000990         let file = s:GetCurrentFile()
  108              0.002205         if !empty(file) && file !~ "-MiniBufExplorer-" && file !~ "--NO NAME--" && file !~ "^term:"
  108   0.005753   0.001847             let last = s:GetLastHeartbeat()
  108              0.000326             let now = localtime()
                            
                                        " Create a heartbeat when saving a file, when the current file
                                        " changes, and when still editing the same file but enough time
                                        " has passed since the last heartbeat.
  108   0.002603   0.001071             if a:is_write || s:EnoughTimePassed(now, last) || file != last.file
    1   0.003056   0.000691                 call s:AppendHeartbeat(file, now, a:is_write, last)
    1              0.000004             else
  107              0.000350                 if now - s:last_heartbeat.last_activity_at > s:local_cache_expire
    3   0.000053   0.000026                     call s:SetLastHeartbeatInMemory(now, last.last_heartbeat_at, last.file)
    3              0.000003                 endif
  107              0.000081             endif
                            
                                        " When buffering heartbeats disabled, no need to re-check the
                                        " heartbeats buffer.
  108              0.000191             if s:buffering_heartbeats_enabled
                            
                                            " Only send buffered heartbeats every s:send_buffer_seconds
  108              0.000297                 if now - s:last_sent > s:send_buffer_seconds
    3   0.002563   0.000079                     call s:SendHeartbeats()
    3              0.000002                 endif
  108              0.000079             endif
  108              0.000062         endif

FUNCTION  <SNR>142_CloseCompletionMenu()
Called 91 times
Total time:   0.001250
 Self time:   0.000910

count  total (s)   self (s)
   91              0.000302   if pumvisible()
   21   0.000526   0.000186     call s:SendKeys( "\<C-e>" )
   21              0.000026   endif

FUNCTION  airline#themes#get_highlight()
Called 126 times
Total time:   0.017403
 Self time:   0.001081

count  total (s)   self (s)
  126   0.017361   0.001039   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  <SNR>97_find_start_of_multiline_statement()
Called 1 time
Total time:   0.068801
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000001     let lnum = a:lnum
    1              0.000001     while lnum > 0
    1              0.000003         if getline(lnum - 1) =~# '\\$'
                                        let lnum = prevnonblank(lnum - 1)
                                    else
    1   0.068788   0.000012             let [paren_lnum, _] = s:find_opening_paren(lnum)
    1              0.000002             if paren_lnum < 1
    1              0.000001                 return lnum
                                        else
                                            let lnum = paren_lnum
                                        endif
                                    endif
                                endwhile

FUNCTION  ale#linter#ResolveFiletype()
Called 6 times
Total time:   0.000573
 Self time:   0.000124

count  total (s)   self (s)
    6   0.000516   0.000067     let l:filetype = s:GetAliasedFiletype(a:original_filetype)
                            
    6              0.000032     if type(l:filetype) != type([])
    6              0.000015         return [l:filetype]
                                endif
                            
                                return l:filetype

FUNCTION  ale#highlight#RemoveHighlights()
Called 4 times
Total time:   0.024086
 Self time:   0.024086

count  total (s)   self (s)
 3207              0.008785     for l:match in getmatches()
 3203              0.005383         if l:match.group =~# '^ALE'
 3116              0.005181             call matchdelete(l:match.id)
 3116              0.001560         endif
 3203              0.002180     endfor

FUNCTION  <SNR>19_joinUndo()
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000006   if v:version < 704 || ( v:version == 704 && !has('patch849') )
                                return ''
                              endif
    1              0.000003   return "\<C-G>U"

FUNCTION  ale#sign#FindCurrentSigns()
Called 4 times
Total time:   0.101726
 Self time:   0.000101

count  total (s)   self (s)
    4   0.003601   0.000026     let l:line_list = ale#sign#ReadSigns(a:buffer)
                            
    4   0.098117   0.000067     return ale#sign#ParseSigns(l:line_list)

FUNCTION  ale#statusline#Count()
Called 358 times
Total time:   0.009629
 Self time:   0.003011

count  total (s)   self (s)
                                " The Dictionary is copied here before exposing it to other plugins.
  358   0.009289   0.002671     return copy(s:GetCounts(a:buffer))

FUNCTION  <SNR>135_TemporaryFilename()
Called 3 times
Total time:   0.000098
 Self time:   0.000098

count  total (s)   self (s)
    3              0.000012     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
    3              0.000006     if empty(l:filename)
                                    " If the buffer's filename is empty, create a dummy filename.
                                    let l:ft = getbufvar(a:buffer, '&filetype')
                                    let l:filename = 'file' . ale#filetypes#GuessExtension(l:ft)
                                endif
                            
                                " Create a temporary filename, <temp_dir>/<original_basename>
                                " The file itself will not be created by this function.
    3              0.000026     return tempname() . (has('win32') ? '\' : '/') . l:filename

FUNCTION  <SNR>142_PollCompletion()
Called 116 times
Total time:   0.040932
 Self time:   0.005105

count  total (s)   self (s)
  116   0.016209   0.001731   if !s:Pyeval( 'ycm_state.CompletionRequestReady()' )
   75              0.001039     let s:pollers.completion.id = timer_start( s:pollers.completion.wait_milliseconds, function( 's:PollCompletion' ) )
   75              0.000109     return
                              endif
                            
   41   0.020373   0.000565   let response = s:Pyeval( 'ycm_state.GetCompletionResponse()' )
   41              0.000454   let s:completion = {   'start_column': response.completion_start_column,   'candidates': response.completions }
   41   0.001894   0.000353   call s:Complete()

FUNCTION  ale#history#Get()
Called 8 times
Total time:   0.000094
 Self time:   0.000094

count  total (s)   self (s)
    8              0.000090     return copy(getbufvar(a:buffer, 'ale_history', []))

FUNCTION  ale#FileTooLarge()
Called 71 times
Total time:   0.000994
 Self time:   0.000994

count  total (s)   self (s)
   71              0.000541     let l:max = getbufvar(a:buffer, 'ale_maximum_file_size', get(g:, 'ale_maximum_file_size', 0))
                            
   71              0.000285     return l:max > 0 ? (line2byte(line('$') + 1) > l:max) : 0

FUNCTION  <SNR>147_GroupLoclistItems()
Called 4 times
Total time:   0.032553
 Self time:   0.032553

count  total (s)   self (s)
    4              0.000009     let l:grouped_items = []
    4              0.000005     let l:last_lnum = -1
                            
 3121              0.002163     for l:obj in a:loclist
 3117              0.003072         if l:obj.bufnr != a:buffer
                                        continue
                                    endif
                            
                                    " Create a new sub-List when we hit a new line.
 3117              0.003070         if l:obj.lnum != l:last_lnum
 3117              0.004851             call add(l:grouped_items, [])
 3117              0.001531         endif
                            
 3117              0.005915         call add(l:grouped_items[-1], l:obj)
 3117              0.003424         let l:last_lnum = l:obj.lnum
 3117              0.002163     endfor
                            
    4              0.000010     return l:grouped_items

FUNCTION  airline#parts#filetype()
Called 179 times
Total time:   0.001021
 Self time:   0.001021

count  total (s)   self (s)
  179              0.000945   return winwidth(0) < 90 && strlen(&filetype) > 3 ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '…' : '>') : &filetype

FUNCTION  airline#parts#iminsert()
Called 179 times
Total time:   0.001014
 Self time:   0.001014

count  total (s)   self (s)
  179              0.000385   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
                              endif
  179              0.000120   return ''

FUNCTION  <SNR>142_OnCompleteDone()
Called 43 times
Total time:   0.005802
 Self time:   0.005802

count  total (s)   self (s)
   43              0.005762   exec s:python_command "ycm_state.OnCompleteDone()"

FUNCTION  ale#python#FindProjectRoot()
Called 6 times
Total time:   0.005707
 Self time:   0.000440

count  total (s)   self (s)
    6   0.004425   0.000043     let l:ini_root = ale#python#FindProjectRootIni(a:buffer)
                            
    6              0.000013     if !empty(l:ini_root)
                                  return l:ini_root
                                endif
                            
    6   0.001126   0.000241     for l:path in ale#path#Upwards(expand('#' . a:buffer . ':p:h'))
    6              0.000096         if !filereadable(l:path . '/__init__.py')
    6              0.000009             return l:path
                                    endif
                                endfor
                            
                                return ''

FUNCTION  airline#highlighter#highlight()
Called 5 times
Total time:   0.162926
 Self time:   0.021453

count  total (s)   self (s)
    5              0.000019   let bufnr = a:0 ? a:1 : ''
    5              0.000023   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
    5              0.000074   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
    5              0.000016   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
   14              0.000029   for mode in mapped
    9              0.000030     if mode == 'inactive' && winnr('$') == 1
                                  " there exist no inactive windows, don't need to create all those
                                  " highlighting groups
                                  continue
                                endif
    9              0.000064     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
    9              0.000038       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
  133              0.000481       for kvp in items(dict)
  124              0.000349         let mode_colors = kvp[1]
  124              0.000264         let name = kvp[0]
  124              0.000445         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
                                      let name = 'airline_c'.bufnr
                                    endif
  124   0.035909   0.001089         call airline#highlighter#exec(name.suffix, mode_colors)
                            
  372              0.000962         for accent in keys(s:accents)
  248              0.000753           if !has_key(p.accents, accent)
                                        continue
                                      endif
  248              0.001230           let colors = copy(mode_colors)
  248              0.000839           if p.accents[accent][0] != ''
  124              0.000388             let colors[0] = p.accents[accent][0]
  124              0.000117           endif
  248              0.000622           if p.accents[accent][2] != ''
                                        let colors[2] = p.accents[accent][2]
                                      endif
  248              0.000525           if len(colors) >= 5
  248              0.001007             let colors[4] = get(p.accents[accent], 4, '')
  248              0.000213           else
                                        call add(colors, get(p.accents[accent], 4, ''))
                                      endif
  248   0.072421   0.002745           call airline#highlighter#exec(name.suffix.'_'.accent, colors)
  248              0.000259         endfor
  124              0.000234       endfor
                            
                                  " TODO: optimize this
   72              0.000324       for sep in items(s:separators)
   63   0.037752   0.000775         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
   63              0.000092       endfor
    9              0.000015     endif
    9              0.000026   endfor

FUNCTION  <SNR>115_Get()
Called 770 times
Total time:   0.005585
 Self time:   0.005585

count  total (s)   self (s)
  770              0.002288   let res=get(a:dict, a:key, '')
  770              0.001171   if res is ''
  395              0.000333     return ''
                              else
  375              0.000671     return a:prefix. res
                              endif

FUNCTION  <SNR>68_SendHeartbeats()
Called 3 times
Total time:   0.002484
 Self time:   0.001861

count  total (s)   self (s)
    3              0.000010         let start_time = localtime()
    3              0.000009         let stdout = ''
                            
    3              0.000009         if len(s:heartbeats_buffer) == 0
    2              0.000002             let s:last_sent = start_time
    2              0.000001             return
                                    endif
                            
    1              0.000004         let heartbeat = s:heartbeats_buffer[0]
    1              0.000020         let s:heartbeats_buffer = s:heartbeats_buffer[1:-1]
    1              0.000003         if len(s:heartbeats_buffer) > 0
                                        let extra_heartbeats = s:GetHeartbeatsJson()
                                    else
    1              0.000035             let extra_heartbeats = ''
    1              0.000004         endif
                            
    1   0.000295   0.000018         let cmd = s:GetCommandPrefix() + ['--entity', heartbeat.entity]
    1              0.000006         let cmd = cmd + ['--time', heartbeat.time]
    1   0.000025   0.000015         let cmd = cmd + ['--plugin', printf('vim/%s vim-wakatime/%s', s:n2s(v:version), s:VERSION)]
    1              0.000001         if heartbeat.is_write
    1              0.000006             let cmd = cmd + ['--write']
    1              0.000001         endif
    1              0.000003         if has_key(heartbeat, 'language')
    1              0.000007             let cmd = cmd + ['--language', heartbeat.language]
    1              0.000001         endif
    1              0.000002         if extra_heartbeats != ''
                                        let cmd = cmd + ['--extra-heartbeats']
                                    endif
                            
                                    " overwrite shell
    1              0.000007         let [sh, shellcmdflag, shrd] = [&shell, &shellcmdflag, &shellredir]
    1   0.000013   0.000004         if !s:IsWindows()
    1              0.000016             set shell=sh shellredir=>%s\ 2>&1
    1              0.000001         endif
                            
    1              0.000002         if s:has_async
    1   0.000013   0.000004             if s:IsWindows()
                                            let job_cmd = [&shell, &shellcmdflag] + cmd
                                        else
    1   0.000329   0.000011                 let job_cmd = [&shell, &shellcmdflag, s:JoinArgs(cmd)]
    1              0.000001             endif
    1              0.001323             let job = job_start(job_cmd, { 'stoponexit': '', 'callback': {channel, output -> s:AsyncHandler(output, cmd)}})
    1              0.000019             if extra_heartbeats != ''
                                            let channel = job_getchannel(job)
                                            call ch_sendraw(channel, extra_heartbeats . "\n")
                                        endif
    1              0.000001         elseif s:nvim_async
                                        let s:nvim_async_output = ['']
                                        let job = jobstart([&shell, &shellcmdflag, s:JoinArgs(cmd)], { 'detach': 1, 'on_stdout': function('s:NeovimAsyncOutputHandler'), 'on_stderr': function('s:NeovimAsyncOutputHandler'), 'on_exit': function('s:NeovimAsyncExitHandler')})
                                        if extra_heartbeats != ''
                                            call jobsend(job, extra_heartbeats . "\n")
                                        endif
                                    elseif s:IsWindows()
                                        if s:is_debug_on
                                            if extra_heartbeats != ''
                                                let stdout = system('(' . s:JoinArgs(cmd) . ')', extra_heartbeats)
                                            else
                                                let stdout = system('(' . s:JoinArgs(cmd) . ')')
                                            endif
                                        else
                                            exec 'silent !start /b cmd /c "' . s:JoinArgs(cmd) . ' > nul 2> nul"'
                                        endif
                                    else
                                        if s:is_debug_on
                                            if extra_heartbeats != ''
                                                let stdout = system(s:JoinArgs(cmd), extra_heartbeats)
                                            else
                                                let stdout = system(s:JoinArgs(cmd))
                                            endif
                                        else
                                            if extra_heartbeats != ''
                                                let stdout = system(s:JoinArgs(cmd) . ' &', extra_heartbeats)
                                            else
                                                let stdout = system(s:JoinArgs(cmd) . ' &')
                                            endif
                                        endif
                                    endif
                            
                                    " restore shell
    1              0.000085         let [&shell, &shellcmdflag, &shellredir] = [sh, shellcmdflag, shrd]
                            
    1              0.000010         let s:last_sent = localtime()
                            
                                    " need to repaint in case a key was pressed while sending
    1              0.000003         if !s:has_async && !s:nvim_async && s:redraw_setting != 'disabled'
                                        if s:redraw_setting == 'auto'
                                            if s:last_sent - start_time > 0
                                                redraw!
                                            endif
                                        else
                                            redraw!
                                        endif
                                    endif
                            
    1              0.000002         if s:is_debug_on && stdout != ''
                                        echoerr '[WakaTime] Heartbeat Command: ' . s:JoinArgs(cmd) . "\n[WakaTime] Error: " . stdout
                                    endif

FUNCTION  SaveCurrentLength()
Called 1 time
Total time:   0.000275
 Self time:   0.000275

count  total (s)   self (s)
    1              0.000009 python3 << endOfPython
                            import vim
                            line = vim.current.line
                            vim.command("let b:autoformat_lastlength = {}".format(len(line)))
                            endOfPython
    1              0.000004 return ''

FUNCTION  <SNR>97_find_opening_paren()
Called 4 times
Total time:   0.291669
 Self time:   0.094467

count  total (s)   self (s)
                                " optional arguments: line and column (defaults to 1) to search around
    4              0.000008     if a:0 > 0
    2              0.000012         let view = winsaveview()
    2              0.000011         call cursor(a:1, a:0 > 1 ? a:2 : 1)
    2              0.000010         let ret = s:find_opening_paren()
    2              0.000061         call winrestview(view)
    2              0.000002         return ret
                                endif
                            
                                " Return if cursor is in a comment.
    2              0.000425     exe 'if' s:skip_search '| return [0, 0] | endif'
                            
    2              0.000006     let nearest = [0, 0]
    8              0.000043     for [p, maxoff] in items(s:paren_pairs)
    6              0.000047         let stopline = max([0, line('.') - maxoff, nearest[0]])
    6   0.145134   0.093825         let next = searchpairpos( '\V'.p[0], '', '\V'.p[1], 'bnW', s:skip_special_chars, stopline)
    6              0.000030         if next[0] && (next[0] > nearest[0] || (next[0] == nearest[0] && next[1] > nearest[1]))
                                        let nearest = next
                                    endif
    6              0.000009     endfor
    2              0.000004     return nearest

FUNCTION  <SNR>19_is_forbidden()
Called 2 times
Total time:   0.001219
 Self time:   0.000201

count  total (s)   self (s)
    2   0.000094   0.000064   if s:is_excluded_ft(&filetype)
                                return 1
                              endif
    2   0.000133   0.000030   if !s:get('excluded_regions_enabled')
                                return 0
                              endif
    2   0.000818   0.000023   let region = s:get_syn_name()
    2   0.000150   0.000060   return index(s:get('excluded_regions_list'), region) >= 0

FUNCTION  <SNR>97_is_concealed()
Called 192 times
Total time:   0.052008
 Self time:   0.052008

count  total (s)   self (s)
  192              0.051221     let concealed = synconcealed(a:line, a:col)
  192              0.000658     return len(concealed) && concealed[0]

FUNCTION  <SNR>148_SetListsImpl()
Called 4 times
Total time:   0.211292
 Self time:   0.007296

count  total (s)   self (s)
    4              0.000312     let l:title = expand('#' . a:buffer . ':p')
                            
    4              0.000009     if g:ale_set_quickfix
                                    let l:quickfix_list = ale#list#GetCombinedList()
                            
                                    if has('nvim')
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list), ' ', l:title)
                                    else
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list))
                                        call setqflist([], 'r', {'title': l:title})
                                    endif
                                elseif g:ale_set_loclist
                                    " If windows support is off, bufwinid() may not exist.
                                    " We'll set result in the current window, which might not be correct,
                                    " but it's better than nothing.
    4   0.000071   0.000040         let l:id = s:BufWinId(a:buffer)
                            
    4              0.000015         if has('nvim')
                                        call setloclist(l:id, s:FixList(a:buffer, a:loclist), ' ', l:title)
                                    else
    4   0.210032   0.006440             call setloclist(l:id, s:FixList(a:buffer, a:loclist))
    4              0.000128             call setloclist(l:id, [], 'r', {'title': l:title})
    4              0.000005         endif
    4              0.000002     endif
                            
                                " Open a window to show the problems if we need to.
                                "
                                " We'll check if the current buffer's List is not empty here, so the
                                " window will only be opened if the current buffer has problems.
    4   0.000203   0.000038     if s:ShouldOpen(a:buffer) && !empty(a:loclist)
                                    let l:winnr = winnr()
                                    let l:mode = mode()
                                    let l:reset_visual_selection = l:mode is? 'v' || l:mode is# "\<c-v>"
                                    let l:reset_character_selection = l:mode is? 's' || l:mode is# "\<c-s>"
                            
                                    " open windows vertically instead of default horizontally
                                    let l:open_type = ''
                                    if ale#Var(a:buffer, 'list_vertical') == 1
                                        let l:open_type = 'vert '
                                    endif
                                    if g:ale_set_quickfix
                                        if !ale#list#IsQuickfixOpen()
                                            silent! execute l:open_type . 'copen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                        endif
                                    elseif g:ale_set_loclist
                                        silent! execute l:open_type . 'lopen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                    endif
                            
                                    " If focus changed, restore it (jump to the last window).
                                    if l:winnr isnot# winnr()
                                        wincmd p
                                    endif
                            
                                    if l:reset_visual_selection || l:reset_character_selection
                                        " If we were in a selection mode before, select the last selection.
                                        normal! gv
                            
                                        if l:reset_character_selection
                                            " Switch back to Select mode, if we were in that.
                                            normal! "\<c-g>"
                                        endif
                                    endif
                                endif
                            
                                " If ALE isn't currently checking for more problems, close the window if
                                " needed now. This check happens inside of this timer function, so
                                " the window can be closed reliably.
    4   0.000056   0.000017     if !ale#engine#IsCheckingBuffer(a:buffer)
    3   0.000198   0.000029         call s:CloseWindowIfNeeded(a:buffer)
    3              0.000002     endif

FUNCTION  ale#history#RememberOutput()
Called 4 times
Total time:   0.000121
 Self time:   0.000038

count  total (s)   self (s)
    4   0.000110   0.000027     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
    4              0.000008     let l:obj.output = a:output

FUNCTION  ale#engine#ManageDirectory()
Called 3 times
Total time:   0.000065
 Self time:   0.000028

count  total (s)   self (s)
    3   0.000049   0.000012     call ale#engine#InitBufferInfo(a:buffer)
    3              0.000012     call add(g:ale_buffer_info[a:buffer].temporary_directory_list, a:directory)

FUNCTION  ale#ShouldDoNothing()
Called 71 times
Total time:   0.009635
 Self time:   0.007477

count  total (s)   self (s)
                                " The checks are split into separate if statements to make it possible to
                                " profile each check individually with Vim's profiling tools.
                            
                                " Do nothing if ALE is disabled.
   71              0.000584     if !getbufvar(a:buffer, 'ale_enabled', get(g:, 'ale_enabled', 0))
                                    return 1
                                endif
                            
                                " Don't perform any checks when newer NeoVim versions are exiting.
   71              0.000319     if get(v:, 'exiting', v:null) isnot v:null
                                    return 1
                                endif
                            
   71              0.000470     let l:filetype = getbufvar(a:buffer, '&filetype')
                            
                                " Do nothing when there's no filetype.
   71              0.000164     if l:filetype is# ''
                                    return 1
                                endif
                            
                                " Do nothing for blacklisted files.
   71              0.000566     if index(get(g:, 'ale_filetype_blacklist', []), l:filetype) >= 0
                                    return 1
                                endif
                            
                                " Do nothing if running from command mode.
   71              0.000348     if s:getcmdwintype_exists && !empty(getcmdwintype())
                                    return 1
                                endif
                            
   71              0.000482     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
                                " Do nothing for directories.
   71              0.000133     if l:filename is# '.'
                                    return 1
                                endif
                            
                                " Do nothing if running in the sandbox.
   71   0.001814   0.000650     if ale#util#InSandbox()
                                    return 1
                                endif
                            
                                " Do nothing if the file is too large.
   71   0.001463   0.000469     if ale#FileTooLarge(a:buffer)
                                    return 1
                                endif
                            
                                " Do nothing from CtrlP buffers with CtrlP-funky.
   71              0.000809     if exists(':CtrlPFunky') is 2&& getbufvar(a:buffer, '&l:statusline') =~# 'CtrlPMode.*funky'
                                    return 1
                                endif
                            
   71              0.000061     return 0

FUNCTION  airline#extensions#ale#get_error()
Called 179 times
Total time:   0.014469
 Self time:   0.001044

count  total (s)   self (s)
  179   0.014409   0.000984   return airline#extensions#ale#get('error')

FUNCTION  <SNR>131_RunJob()
Called 4 times
Total time:   0.026833
 Self time:   0.001941

count  total (s)   self (s)
    4              0.000009     let l:command = a:options.command
    4              0.000007     let l:buffer = a:options.buffer
    4              0.000004     let l:linter = a:options.linter
    4              0.000007     let l:output_stream = a:options.output_stream
    4              0.000008     let l:next_chain_index = a:options.next_chain_index
    4              0.000006     let l:read_buffer = a:options.read_buffer
    4              0.000058     let l:info = g:ale_buffer_info[l:buffer]
                            
    4              0.000009     if empty(l:command)
                                    return 0
                                endif
                            
    4   0.000695   0.000036     let [l:temporary_file, l:command] = ale#command#FormatCommand(l:buffer, l:command, l:read_buffer)
                            
    4   0.019828   0.000535     if s:CreateTemporaryFileForJob(l:buffer, l:temporary_file)
                                    " If a temporary filename has been formatted in to the command, then
                                    " we do not need to send the Vim buffer to the command.
    3              0.000014         let l:read_buffer = 0
    3              0.000003     endif
                            
                                " Add a newline to commands which need it.
                                " This is only used for Flow for now, and is not documented.
    4              0.000010     if l:linter.add_newline
                                    if has('win32')
                                        let l:command = l:command . '; echo.'
                                    else
                                        let l:command = l:command . '; echo'
                                    endif
                                endif
                            
    4   0.000371   0.000056     let l:command = ale#job#PrepareCommand(l:buffer, l:command)
    4              0.000030     let l:job_options = {   'mode': 'nl',   'exit_cb': function('s:HandleExit'),}
                            
    4              0.000009     if l:output_stream is# 'stderr'
                                    let l:job_options.err_cb = function('s:GatherOutput')
                                elseif l:output_stream is# 'both'
                                    let l:job_options.out_cb = function('s:GatherOutput')
                                    let l:job_options.err_cb = function('s:GatherOutput')
                                else
    4              0.000017         let l:job_options.out_cb = function('s:GatherOutput')
    4              0.000003     endif
                            
    4              0.000011     if get(g:, 'ale_run_synchronously') == 1
                                    " Find a unique Job value to use, which will be the same as the ID for
                                    " running commands synchronously. This is only for test code.
                                    let l:job_id = len(s:job_info_map) + 1
                            
                                    while has_key(s:job_info_map, l:job_id)
                                        let l:job_id += 1
                                    endwhile
                                else
    4   0.004661   0.000309         let l:job_id = ale#job#Start(l:command, l:job_options)
    4              0.000011     endif
                            
    4              0.000006     let l:status = 'failed'
                            
                                " Only proceed if the job is being run.
    4              0.000003     if l:job_id
                                    " Add the job to the list of jobs, so we can track them.
    4              0.000050         call add(l:info.job_list, l:job_id)
                            
    4              0.000036         if index(l:info.active_linter_list, l:linter.name) < 0
    4              0.000018             call add(l:info.active_linter_list, l:linter.name)
    4              0.000003         endif
                            
    4              0.000005         let l:status = 'started'
                                    " Store the ID for the job in the map to read back again.
    4              0.000044         let s:job_info_map[l:job_id] = {   'linter': l:linter,   'buffer': l:buffer,   'output': [],   'next_chain_index': l:next_chain_index,}
                            
    4   0.000292   0.000263         silent doautocmd <nomodeline> User ALEJobStarted
    4              0.000004     endif
                            
    4              0.000009     if g:ale_history_enabled
    4   0.000293   0.000049         call ale#history#Add(l:buffer, l:status, l:job_id, l:command)
    4              0.000003     endif
                            
    4              0.000023     if get(g:, 'ale_run_synchronously') == 1
                                    " Run a command synchronously if this test option is set.
                                    let s:job_info_map[l:job_id].output = systemlist(   type(l:command) == type([])   ?  join(l:command[0:1]) . ' ' . ale#Escape(l:command[2])   : l:command)
                            
                                    call l:job_options.exit_cb(l:job_id, v:shell_error)
                                endif
                            
    4              0.000020     return l:job_id != 0

FUNCTION  ale#Var()
Called 176 times
Total time:   0.005762
 Self time:   0.005762

count  total (s)   self (s)
  176              0.000860     let l:nr = str2nr(a:buffer)
  176              0.000662     let l:full_name = 'ale_' . a:variable_name
                            
  176              0.000546     if bufexists(l:nr)
  176              0.000669         let l:vars = getbufvar(l:nr, '')
  176              0.000416     elseif has_key(g:, 'ale_fix_buffer_data')
                                    let l:vars = get(g:ale_fix_buffer_data, l:nr, {'vars': {}}).vars
                                else
                                    let l:vars = {}
                                endif
                            
  176              0.000898     return get(l:vars, l:full_name, g:[l:full_name])

FUNCTION  delimitMate#IsEmptyPair()
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000016   if strlen(substitute(a:str, ".", "x", "g")) != 2
    1              0.000002     return 0
                              endif
                              let idx = index(s:get('left_delims'), matchstr(a:str, '^.'))
                              if idx > -1 && s:get('right_delims')[idx] == matchstr(a:str, '.$')
                                return 1
                              endif
                              let idx = index(s:get('quotes_list'), matchstr(a:str, '^.'))
                              if idx > -1 && s:get('quotes_list')[idx] == matchstr(a:str, '.$')
                                return 1
                              endif
                              return 0

FUNCTION  <SNR>110_check_mixed_indent_file()
Called 1 time
Total time:   0.016759
 Self time:   0.016759

count  total (s)   self (s)
    1              0.000009   let c_like_langs = get(g:, 'airline#extensions#c_like_langs', [ 'arduino', 'c', 'cpp', 'cuda', 'go', 'javascript', 'ld', 'php' ])
    1              0.000006   if index(c_like_langs, &ft) > -1
                                " for C-like languages: allow /** */ comment style with one space before the '*'
                                let head_spc = '\v(^ +\*@!)'
                              else
    1              0.000001     let head_spc = '\v(^ +)'
    1              0.000001   endif
    1              0.016683   let indent_tabs = search('\v(^\t+)', 'nw')
    1              0.000038   let indent_spc  = search(head_spc, 'nw')
    1              0.000004   if indent_tabs > 0 && indent_spc > 0
                                return printf("%d:%d", indent_tabs, indent_spc)
                              else
    1              0.000002     return ''
                              endif

FUNCTION  <SNR>19_get_char()
Called 6 times
Total time:   0.000263
 Self time:   0.000263

count  total (s)   self (s)
    6              0.000035   let idx = col('.') - 1
    6              0.000019   if !a:0 || (a:0 && a:1 >= 0)
                                " Get char from cursor.
    3              0.000018     let line = getline('.')[idx :]
    3              0.000009     let pos = a:0 ? a:1 : 0
    3              0.000035     return matchstr(line, '^'.repeat('.', pos).'\zs.')
                              endif
                              " Get char behind cursor.
    3              0.000021   let line = getline('.')[: idx - 1]
    3              0.000012   let pos = 0 - (1 + a:1)
    3              0.000051   return matchstr(line, '.\ze'.repeat('.', pos).'$')

FUNCTION  delimitMate#ParenDelim()
Called 1 time
Total time:   0.001143
 Self time:   0.000216

count  total (s)   self (s)
    1   0.000148   0.000037   let left = s:get('left_delims')[index(s:get('right_delims'),a:right)]
    1   0.000637   0.000010   if s:is_forbidden(a:right)
                                return left
                              endif
                              " Try to balance matchpairs
    1   0.000048   0.000012   if s:get('balance_matchpairs') && s:balance_matchpairs(a:right) < 0
                                return left
                              endif
    1              0.000006   let line = getline('.')
    1              0.000005   let col = col('.')-2
    1   0.000044   0.000008   if s:get('smart_matchpairs') != ''
    1   0.000060   0.000026     let smart_matchpairs = substitute(s:get('smart_matchpairs'), '\\!', left, 'g')
    1              0.000012     let smart_matchpairs = substitute(smart_matchpairs, '\\#', a:right, 'g')
    1              0.000023     if line[col+1:] =~ smart_matchpairs
                                  return left
                                endif
    1              0.000001   endif
    1   0.000047   0.000013   if len(line) == (col + 1) && s:get('insert_eol_marker') == 1
    1   0.000042   0.000008     let tail = s:get('eol_marker')
    1              0.000002   else
                                let tail = ''
                              endif
    1   0.000044   0.000029   return left . a:right . tail . repeat(s:joinUndo() . "\<Left>", len(split(tail, '\zs')) + 1)

FUNCTION  SimpylFold#Recache()
Called 3 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    3              0.000014     if exists('b:SimpylFold_cache')
                                    unlet b:SimpylFold_cache
                                endif

FUNCTION  <SNR>142_AllowedToCompleteInCurrentBuffer()
Called 158 times
Total time:   0.012852
 Self time:   0.001487

count  total (s)   self (s)
  158   0.012769   0.001404   return s:AllowedToCompleteInBuffer( '%' )

FUNCTION  <SNR>107_get_hunks_gitgutter()
Called 179 times
Total time:   0.007658
 Self time:   0.001997

count  total (s)   self (s)
  179   0.002102   0.001041   if !get(g:, 'gitgutter_enabled', 0) || s:is_branch_empty()
                                return ''
                              endif
  179   0.005175   0.000575   return GitGutterGetHunkSummary()

FUNCTION  <SNR>97_indent_like_block()
Called 1 time
Total time:   0.000095
 Self time:   0.000095

count  total (s)   self (s)
    1              0.000003     let text = getline(a:lnum)
    3              0.000011     for [multiple, block_rules] in [ [0, s:block_rules], [1, s:block_rules_multiple]]
    6              0.000014         for [line_re, blocks] in items(block_rules)
    4              0.000011             if text !~# line_re
    4              0.000004                 continue
                                        endif
                            
                                        let indents = s:find_start_of_block(a:lnum - 1, blocks, multiple)
                                        if !len(indents)
                                            return -1
                                        endif
                                        if len(indents) == 1
                                            return indents[0]
                                        endif
                            
                                        " Multiple valid indents, e.g. for 'else' with both try and if.
                                        let indent = indent(a:lnum)
                                        if index(indents, indent) != -1
                                            " The indent is valid, keep it.
                                            return indent
                                        endif
                                        " Fallback to the first/nearest one.
                                        return indents[0]
                                    endfor
    2              0.000001     endfor
    1              0.000001     return -2

FUNCTION  ale#util#Writefile()
Called 3 times
Total time:   0.018348
 Self time:   0.018348

count  total (s)   self (s)
    3              0.000022     let l:corrected_lines = getbufvar(a:buffer, '&fileformat') is# 'dos'   ? map(copy(a:lines), 'v:val . "\r"')   : a:lines
                            
    3              0.018321     call writefile(l:corrected_lines, a:filename) " no-custom-checks

FUNCTION  ale_linters#python#mypy#GetExecutable()
Called 6 times
Total time:   0.016733
 Self time:   0.000083

count  total (s)   self (s)
    6   0.016729   0.000079     return ale#python#FindExecutable(a:buffer, 'python_mypy', ['mypy'])

FUNCTION  <SNR>147_UpdateLineNumbers()
Called 4 times
Total time:   0.044127
 Self time:   0.044127

count  total (s)   self (s)
    4              0.000009     let l:line_map = {}
    4              0.000006     let l:line_numbers_changed = 0
                            
 3120              0.003844     for [l:line, l:sign_id, l:name] in a:current_sign_list
 3116              0.008173         let l:line_map[l:sign_id] = l:line
 3116              0.002080     endfor
                            
 3121              0.002268     for l:item in a:loclist
 3117              0.003123         if l:item.bufnr == a:buffer
 3117              0.009161             let l:lnum = get(l:line_map, get(l:item, 'sign_id', 0), 0)
                            
 3117              0.003651             if l:lnum && l:item.lnum != l:lnum
                                            let l:item.lnum = l:lnum
                                            let l:line_numbers_changed = 1
                                        endif
 3117              0.001482         endif
 3117              0.001999     endfor
                            
                                " When the line numbers change, sort the list again
    4              0.000005     if l:line_numbers_changed
                                    call sort(a:loclist, 'ale#util#LocItemCompare')
                                endif

FUNCTION  ale#GetLocItemMessage()
Called 3117 times
Total time:   0.137807
 Self time:   0.137807

count  total (s)   self (s)
 3117              0.005111     let l:msg = a:format_string
 3117              0.004898     let l:severity = g:ale_echo_msg_warning_str
 3117              0.007051     let l:code = get(a:item, 'code', '')
 3117              0.006406     let l:type = get(a:item, 'type', 'E')
 3117              0.007922     let l:linter_name = get(a:item, 'linter_name', '')
 3117              0.008632     let l:code_repl = !empty(l:code) ? '\=submatch(1) . l:code . submatch(2)' : ''
                            
 3117              0.003826     if l:type is# 'E'
    1              0.000002         let l:severity = g:ale_echo_msg_error_str
    1              0.000001     elseif l:type is# 'I'
                                    let l:severity = g:ale_echo_msg_info_str
                                endif
                            
                                " Replace special markers with certain information.
                                " \=l:variable is used to avoid escaping issues.
 3117              0.017631     let l:msg = substitute(l:msg, '\V%severity%', '\=l:severity', 'g')
 3117              0.015411     let l:msg = substitute(l:msg, '\V%linter%', '\=l:linter_name', 'g')
 3117              0.018947     let l:msg = substitute(l:msg, '\v\%([^\%]*)code([^\%]*)\%', l:code_repl, 'g')
                                " Replace %s with the text.
 3117              0.014377     let l:msg = substitute(l:msg, '\V%s', '\=a:item.text', 'g')
                            
 3117              0.003348     return l:msg

FUNCTION  <SNR>68_n2s()
Called 3 times
Total time:   0.000095
 Self time:   0.000095

count  total (s)   self (s)
    3              0.000082         return substitute(printf('%d', a:number), ',', '.', '')

FUNCTION  ale#job#Stop()
Called 4 times
Total time:   0.000290
 Self time:   0.000202

count  total (s)   self (s)
    4              0.000013     if !has_key(s:job_map, a:job_id)
                                    return
                                endif
                            
    4              0.000019     if has('nvim')
                                    " FIXME: NeoVim kills jobs on a timer, but will not kill any processes
                                    " which are child processes on Unix. Some work needs to be done to
                                    " kill child processes to stop long-running processes like pylint.
                                    silent! call jobstop(a:job_id)
                                else
    4              0.000014         let l:job = s:job_map[a:job_id].job
                            
                                    " We must close the channel for reading the buffer if it is open
                                    " when stopping a job. Otherwise, we will get errors in the status line.
    4              0.000019         if ch_status(job_getchannel(l:job)) is# 'open'
                                        call ch_close_in(job_getchannel(l:job))
                                    endif
                            
                                    " Ask nicely for the job to stop.
    4              0.000027         call job_stop(l:job)
                            
    4   0.000118   0.000030         if ale#job#IsRunning(l:job)
                                        " Set a 100ms delay for killing the job with SIGKILL.
                                        let s:job_kill_timers[timer_start(100, function('s:KillHandler'))] = l:job
                                    endif
    4              0.000003     endif

FUNCTION  ale#engine#InitBufferInfo()
Called 6 times
Total time:   0.000101
 Self time:   0.000101

count  total (s)   self (s)
    6              0.000026     if !has_key(g:ale_buffer_info, a:buffer)
                                    " job_list will hold the list of job IDs
                                    " active_linter_list will hold the list of active linter names
                                    " loclist holds the loclist items after all jobs have completed.
                                    " temporary_file_list holds temporary files to be cleaned up
                                    " temporary_directory_list holds temporary directories to be cleaned up
                                    let g:ale_buffer_info[a:buffer] = {   'job_list': [],   'active_linter_list': [],   'loclist': [],   'temporary_file_list': [],   'temporary_directory_list': [],}
                            
                                    return 1
                                endif
                            
    6              0.000007     return 0

FUNCTION  <SNR>110_ws_refresh()
Called 1 time
Total time:   0.000215
 Self time:   0.000215

count  total (s)   self (s)
    1              0.000008   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
                                return
                              endif
    1              0.000196   unlet! b:airline_whitespace_check
    1              0.000003   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh'
                              endif
    1              0.000004   let b:airline_ws_changedtick = b:changedtick

FUNCTION  airline#util#shorten()
Called 358 times
Total time:   0.005473
 Self time:   0.005473

count  total (s)   self (s)
  358              0.001643   if winwidth(0) < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return '…'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').'…'
                                endif
                              else
  358              0.000393     return a:text
                              endif

FUNCTION  <SNR>19_get_syn_name()
Called 2 times
Total time:   0.000795
 Self time:   0.000795

count  total (s)   self (s)
    2              0.000014   let col = col('.')
    2              0.000011   if  col == col('$')
    2              0.000008     let col = col - 1
    2              0.000004   endif
    2              0.000755   return synIDattr(synIDtrans(synID(line('.'), col, 1)), 'name')

FUNCTION  ale_linters#python#pylint#Handle()
Called 1 time
Total time:   0.067770
 Self time:   0.013141

count  total (s)   self (s)
                                " Matches patterns like the following:
                                "
                                " test.py:4:4: W0101 (unreachable) Unreachable code
    1              0.000004     let l:pattern = '\v^[a-zA-Z]?:?[^:]+:(\d+):(\d+): ([[:alnum:]]+) \(([^(]*)\) (.*)$'
    1              0.000001     let l:output = []
                            
  781   0.056367   0.001738     for l:match in ale#util#GetMatches(a:lines, l:pattern)
                                    "let l:failed = append(0, l:match)
  780              0.001065         let l:code = l:match[3]
                            
  780              0.001354         if (l:code is# 'C0303') && !ale#Var(a:buffer, 'warn_about_trailing_whitespace')
                                        " Skip warnings for trailing whitespace if the option is off.
                                        continue
                                    endif
                            
  780              0.000765         if l:code is# 'I0011'
                                        " Skip 'Locally disabling' message
                                         continue
                                    endif
                            
  780              0.004843         call add(l:output, {   'lnum': l:match[1] + 0,   'col': l:match[2] + 1,   'text': l:match[5],   'code': l:match[4],   'type': l:code[:0] is# 'E' ? 'E' : 'W',})
  780              0.000544     endfor
                            
    1              0.000002     return l:output

FUNCTION  ale#engine#IsCheckingBuffer()
Called 11 times
Total time:   0.000122
 Self time:   0.000122

count  total (s)   self (s)
   11              0.000057     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
   11              0.000045     return !empty(get(l:info, 'active_linter_list', []))

FUNCTION  <SNR>142_OnBlankLine()
Called 47 times
Total time:   0.005475
 Self time:   0.000264

count  total (s)   self (s)
   47   0.005460   0.000249   return s:Pyeval( 'not vim.current.line or vim.current.line.isspace()' )

FUNCTION  ale#python#FindVirtualenv()
Called 8 times
Total time:   0.023332
 Self time:   0.014126

count  total (s)   self (s)
   72   0.002512   0.000461     for l:path in ale#path#Upwards(expand('#' . a:buffer . ':p:h'))
                                    " Skip empty path components returned in MSYS.
   64              0.000118         if empty(l:path)
                                        continue
                                    endif
                            
  448   0.002536   0.001088         for l:dirname in ale#Var(a:buffer, 'virtualenv_dir_names')
  384   0.005938   0.003071             let l:venv_dir = ale#path#Simplify(   join([l:path, l:dirname], s:sep))
  384   0.006400   0.003560             let l:script_filename = ale#path#Simplify(   join([l:venv_dir, s:bin_dir, 'activate'], s:sep))
                            
  384              0.003424             if filereadable(l:script_filename)
                                            return l:venv_dir
                                        endif
  384              0.000342         endfor
   64              0.000037     endfor
                            
    8              0.000041     return $VIRTUAL_ENV

FUNCTION  <SNR>142_OnCursorMovedNormalMode()
Called 60 times
Total time:   0.015466
 Self time:   0.010424

count  total (s)   self (s)
   60   0.005496   0.000454   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
   60              0.009753   exec s:python_command "ycm_state.OnCursorMoved()"

FUNCTION  <SNR>142_InsideCommentOrString()
Called 47 times
Total time:   0.006948
 Self time:   0.006948

count  total (s)   self (s)
                              " Has to be col('.') -1 because col('.') doesn't exist at this point. We are
                              " in insert mode when this func is called.
   47              0.006411   let syntax_group = synIDattr( synIDtrans( synID( line( '.' ), col( '.' ) - 1, 1 ) ), 'name')
                            
   47              0.000157   if stridx(syntax_group, 'Comment') > -1
                                return 1
                              endif
                            
   47              0.000084   if stridx(syntax_group, 'String') > -1
                                return 2
                              endif
                            
   47              0.000034   return 0

FUNCTION  <SNR>68_SetLastHeartbeatInMemory()
Called 4 times
Total time:   0.000072
 Self time:   0.000072

count  total (s)   self (s)
    4              0.000058         let s:last_heartbeat = {'last_activity_at': a:last_activity_at, 'last_heartbeat_at': a:last_heartbeat_at, 'file': a:file}

FUNCTION  <SNR>131_RemoveProblemsForDisabledLinters()
Called 3 times
Total time:   0.007646
 Self time:   0.007646

count  total (s)   self (s)
                                " Figure out which linters are still enabled, and remove
                                " problems for linters which are no longer enabled.
    3              0.000010     let l:name_map = {}
                            
    9              0.000018     for l:linter in a:linters
    6              0.000025         let l:name_map[l:linter.name] = 1
    6              0.000008     endfor
                            
    3              0.007562     call filter(   get(g:ale_buffer_info[a:buffer], 'loclist', []),   'get(l:name_map, get(v:val, ''linter_name''))',)

FUNCTION  airline#extensions#ale#get()
Called 358 times
Total time:   0.232703
 Self time:   0.029401

count  total (s)   self (s)
  358              0.001245   if !exists(':ALELint')
                                return ''
                              endif
                            
  358              0.000814   let is_err = a:type ==# 'error'
  358              0.000921   let symbol = is_err ? s:error_symbol : s:warning_symbol
                            
  358              0.000561   let is_err = a:type ==# 'error'
  358   0.011502   0.001873   let counts = ale#statusline#Count(bufnr(''))
  358              0.000750   let symbol = is_err ? s:error_symbol : s:warning_symbol
                            
  358              0.001644   if type(counts) == type({}) && has_key(counts, 'error')
                                " Use the current Dictionary format.
  358              0.000774     let errors = counts.error + counts.style_error
  358              0.000727     let num = is_err ? errors : counts.total - errors
  358              0.000238   else
                                " Use the old List format.
                                let num = is_err ? counts[0] : counts[1]
                              endif
                            
  358              0.000471   if s:show_line_numbers == 1
  358   0.210118   0.016445     return s:airline_ale_count(num, symbol) . <sid>airline_ale_get_line_number(num, a:type)
                              else
                                return s:airline_ale_count(num, symbol)
                              endif

FUNCTION  ale#job#ParseVim8ProcessID()
Called 2353 times
Total time:   0.009094
 Self time:   0.009094

count  total (s)   self (s)
 2353              0.008541     return matchstr(a:job_string, '\d\+') + 0

FUNCTION  airline#util#wrap()
Called 1432 times
Total time:   0.007459
 Self time:   0.007459

count  total (s)   self (s)
 1432              0.003281   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
 1432              0.001371   return a:text

FUNCTION  <SNR>115_hl_group_exists()
Called 330 times
Total time:   0.004205
 Self time:   0.004205

count  total (s)   self (s)
  330              0.001066   if !hlexists(a:group)
                                return 0
                              elseif empty(synIDattr(hlID(a:group), 'fg'))
                                return 0
                              endif
  330              0.000347   return 1

FUNCTION  ale#job#ValidateArguments()
Called 4 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    4              0.000012     if a:options.mode isnot# 'nl' && a:options.mode isnot# 'raw'
                                    throw 'Invalid mode: ' . a:options.mode
                                endif

FUNCTION  ale#linter#GetExecutable()
Called 4 times
Total time:   0.014153
 Self time:   0.000072

count  total (s)   self (s)
    4   0.014148   0.000067     return has_key(a:linter, 'executable_callback')   ? ale#util#GetFunction(a:linter.executable_callback)(a:buffer)   : a:linter.executable

FUNCTION  <SNR>147_BuildSignMap()
Called 4 times
Total time:   0.247598
 Self time:   0.140248

count  total (s)   self (s)
    4   0.000164   0.000041     let l:max_signs = ale#Var(a:buffer, 'max_signs')
                            
    4              0.000008     if l:max_signs is 0
                                    let l:selected_grouped_items = []
                                elseif type(l:max_signs) is type(0) && l:max_signs > 0
                                    let l:selected_grouped_items = a:grouped_items[:l:max_signs - 1]
                                else
    4              0.000009         let l:selected_grouped_items = a:grouped_items
    4              0.000002     endif
                            
    4              0.000007     let l:sign_map = {}
    4              0.000008     let l:sign_offset = g:ale_sign_offset
                            
 3120              0.004265     for [l:line, l:sign_id, l:name] in a:current_sign_list
 3116              0.016517         let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
                                    " Increment the sign offset for new signs, by the maximum sign ID.
 3116              0.003769         if l:sign_id > l:sign_offset
 3116              0.003460             let l:sign_offset = l:sign_id
 3116              0.001617         endif
                            
                                    " Remember the sign names and IDs in separate Lists, so they are easy
                                    " to work with.
 3116              0.005675         call add(l:sign_info.current_id_list, l:sign_id)
 3116              0.005662         call add(l:sign_info.current_name_list, l:name)
                            
 3116              0.008178         let l:sign_map[l:line] = l:sign_info
 3116              0.002326     endfor
                            
 3121              0.002610     for l:group in l:selected_grouped_items
 3117              0.004461         let l:line = l:group[0].lnum
 3117              0.018260         let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
 3117   0.119086   0.011859         let l:sign_info.new_name = ale#sign#GetSignName(l:group)
 3117              0.004394         let l:sign_info.items = l:group
                            
 3117              0.007524         let l:index = index(   l:sign_info.current_name_list,   l:sign_info.new_name)
                            
 3117              0.002982         if l:index >= 0
                                        " We have a sign with this name already, so use the same ID.
 3116              0.006068             let l:sign_info.new_id = l:sign_info.current_id_list[l:index]
 3116              0.001757         else
                                        " This sign name replaces the previous name, so use a new ID.
    1              0.000002             let l:sign_info.new_id = l:sign_offset + 1
    1              0.000002             let l:sign_offset += 1
    1              0.000000         endif
                            
 3117              0.005897         let l:sign_map[l:line] = l:sign_info
 3117              0.003278     endfor
                            
    4              0.000005     return l:sign_map

FUNCTION  <SNR>122_GetLinterNames()
Called 6 times
Total time:   0.000152
 Self time:   0.000152

count  total (s)   self (s)
    6              0.000053     let l:buffer_ale_linters = get(b:, 'ale_linters', {})
                            
                                " b:ale_linters can be set to 'all'
    6              0.000016     if l:buffer_ale_linters is# 'all'
                                    return 'all'
                                endif
                            
                                " b:ale_linters can be set to a List.
    6              0.000030     if type(l:buffer_ale_linters) is type([])
    6              0.000015         return l:buffer_ale_linters
                                endif
                            
                                " Try to get a buffer-local setting for the filetype
                                if has_key(l:buffer_ale_linters, a:original_filetype)
                                    return l:buffer_ale_linters[a:original_filetype]
                                endif
                            
                                " Try to get a global setting for the filetype
                                if has_key(g:ale_linters, a:original_filetype)
                                    return g:ale_linters[a:original_filetype]
                                endif
                            
                                " If the user has configured ALE to only enable linters explicitly, then
                                " don't enable any linters by default.
                                if g:ale_linters_explicit
                                    return []
                                endif
                            
                                " Try to get a default setting for the filetype
                                if has_key(s:default_ale_linters, a:original_filetype)
                                    return s:default_ale_linters[a:original_filetype]
                                endif
                            
                                return 'all'

FUNCTION  <SNR>142_InvokeCompletion()
Called 45 times
Total time:   0.070877
 Self time:   0.063825

count  total (s)   self (s)
   45              0.063299   exec s:python_command "ycm_state.SendCompletionRequest(" . "vimsupport.GetBoolValue( 's:force_semantic' ) )"
                            
   45   0.007492   0.000440   call s:PollCompletion()

FUNCTION  <SNR>115_CheckDefined()
Called 440 times
Total time:   0.012774
 Self time:   0.012774

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
  440              0.001810   if !exists("g:airline#highlighter#normal_fg_hi")
                                let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
                              endif
  440              0.001837   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
                                return a:colors
                              endif
                            
  440              0.001295   for val in a:colors
  440              0.001459     if !empty(val) && val !=# 'NONE'
  440              0.000679       return a:colors
                                endif
                              endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
                              let fg = g:airline#highlighter#normal_fg_hi
                              let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                              if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
                              return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  <SNR>68_GetLastHeartbeat()
Called 108 times
Total time:   0.003906
 Self time:   0.003906

count  total (s)   self (s)
  108              0.000981         if !s:last_heartbeat.last_activity_at || localtime() - s:last_heartbeat.last_activity_at > s:local_cache_expire
    3              0.000071             if !filereadable(s:data_file)
                                            return {'last_activity_at': 0, 'last_heartbeat_at': 0, 'file': ''}
                                        endif
    3              0.000111             let last = readfile(s:data_file, '', 3)
    3              0.000010             if len(last) == 3
    3              0.000016                 let s:last_heartbeat.last_heartbeat_at = last[1]
    3              0.000011                 let s:last_heartbeat.file = last[2]
    3              0.000004             endif
    3              0.000002         endif
  108              0.000258         return s:last_heartbeat

FUNCTION  ale#path#BufferCdString()
Called 1 time
Total time:   0.000084
 Self time:   0.000052

count  total (s)   self (s)
    1   0.000083   0.000051     return ale#path#CdString(fnamemodify(bufname(a:buffer), ':p:h'))

FUNCTION  ale_linters#python#pylint#GetExecutable()
Called 2 times
Total time:   0.007439
 Self time:   0.000025

count  total (s)   self (s)
    2   0.007438   0.000024     return ale#python#FindExecutable(a:buffer, 'python_pylint', ['pylint'])

FUNCTION  <SNR>92_FormatCurrentLine()
Called 1 time
Total time:   0.046922
 Self time:   0.046922

count  total (s)   self (s)
    1              0.000001 python3 << endOfPython
                            
                            import autopep8
                            import re
                            import astformat
                            
                            line = vim.current.line
                            row, col = vim.current.window.cursor
                            space = ''
                            if len(line) > 79:
                            	toolong = True
                            else:
                            	toolong = False
                            
                                #for char in line:
                                #	if char == ' ' or char == '\t':
                                #		space = space + char
                                #	else:
                                #		break
                            
                            extra = line.lstrip()
                            space = " " * (len(line) - len(extra))
                            
                            if extra == '':
                            	pass
                            else:
                            	oldextralen = len(extra)
                            	if extra == "##" and (row > 1 and (re.match("^\s*def ", vim.current.buffer[row-2]) or re.match("^\s*class ", vim.current.buffer[row-2]))):
                            		vim.current.line = space + '"""'
                            		vim.current.buffer.append("", row)
                            		vim.current.buffer[row] = space + '"""'
                            		vim.current.window.cursor = (row, len(space) + 3)
                            	elif extra != '':
                            		flag = False
                            		if toolong:
                            			extra, flag = astformat.formatif(extra)
                            		if not flag:
                            			extra = autopep8.fix_code(extra)[:-1]
                            		if '\n' in extra:
                            			extras = extra.split('\n')
                            			for i in range(len(extras)-1):
                            				vim.current.buffer.append("", row)
                            			for i, v in enumerate(extras):
                            				vim.current.buffer[row + i - 1] = space + v
                            			vim.current.window.cursor = (row + len(extras) - 1, len(space) + len(extras[-1]))
                            		else:
                            			expandlen = len(extra) - oldextralen
                            			vim.current.line = space + extra
                            			vim.current.window.cursor = (row, col + expandlen)
                            
                            endOfPython

FUNCTION  <SNR>19_is_excluded_ft()
Called 2 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    2              0.000020   if !exists("g:delimitMate_excluded_ft")
    2              0.000006     return 0
                              endif
                              return index(split(g:delimitMate_excluded_ft, ','), a:ft, 0, 1) >= 0

FUNCTION  ale#Queue()
Called 3 times
Total time:   0.072479
 Self time:   0.001035

count  total (s)   self (s)
    3              0.000014     if a:0 > 2
                                    throw 'too many arguments!'
                                endif
                            
                                " Default linting_flag to ''
    3              0.000024     let l:linting_flag = get(a:000, 0, '')
    3              0.000021     let l:buffer = get(a:000, 1, bufnr(''))
                            
    3              0.000013     if l:linting_flag isnot# '' && l:linting_flag isnot# 'lint_file'
                                    throw "linting_flag must be either '' or 'lint_file'"
                                endif
                            
    3              0.000026     if type(l:buffer) != type(0)
                                    throw 'buffer_number must be a Number'
                                endif
                            
    3   0.000544   0.000033     if ale#ShouldDoNothing(l:buffer)
                                    return
                                endif
                            
                                " Remember that we want to check files for this buffer.
                                " We will remember this until we finally run the linters, via any event.
    3              0.000011     if l:linting_flag is# 'lint_file'
    1              0.000007         let s:should_lint_file_for_buffer[l:buffer] = 1
    1              0.000001     endif
                            
    3              0.000008     if s:lint_timer != -1
                                    call timer_stop(s:lint_timer)
                                    let s:lint_timer = -1
                                endif
                            
    3   0.002099   0.000084     let l:linters = ale#linter#Get(getbufvar(l:buffer, '&filetype'))
                            
                                " Don't set up buffer data and so on if there are no linters to run.
    3              0.000010     if empty(l:linters)
                                    " If we have some previous buffer data, then stop any jobs currently
                                    " running and clear everything.
                                    if has_key(g:ale_buffer_info, l:buffer)
                                        call ale#engine#RunLinters(l:buffer, [], 1)
                                    endif
                            
                                    return
                                endif
                            
    3              0.000006     if a:delay > 0
                                    let s:queued_buffer_number = l:buffer
                                    let s:lint_timer = timer_start(a:delay, function('ale#Lint'))
                                else
    3   0.069145   0.000227         call ale#Lint(-1, l:buffer)
    3              0.000007     endif

FUNCTION  <SNR>142_PollFileParseResponse()
Called 2 times
Total time:   0.000925
 Self time:   0.000645

count  total (s)   self (s)
    2   0.000226   0.000013   if !s:Pyeval( "ycm_state.FileParseRequestReady()" )
                                let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
                                return
                              endif
                            
    2              0.000588   exec s:python_command "ycm_state.HandleFileParseRequest()"
    2   0.000084   0.000017   if s:Pyeval( "ycm_state.ShouldResendFileParseRequest()" )
                                call s:OnFileReadyToParse( 1 )
                              endif

FUNCTION  <SNR>124_GetDir()
Called 6 times
Total time:   0.005791
 Self time:   0.000084

count  total (s)   self (s)
    6   0.005749   0.000042     let l:project_root = ale#python#FindProjectRoot(a:buffer)
                            
    6              0.000035     return !empty(l:project_root)   ? l:project_root   : expand('#' . a:buffer . ':p:h')

FUNCTION  <SNR>148_FixList()
Called 4 times
Total time:   0.203592
 Self time:   0.065702

count  total (s)   self (s)
    4   0.000106   0.000023     let l:format = ale#Var(a:buffer, 'loclist_msg_format')
    4              0.000006     let l:new_list = []
                            
 3121              0.003819     for l:item in a:list
 3117              0.011319         let l:fixed_item = copy(l:item)
                            
 3117   0.155513   0.017706         let l:fixed_item.text = ale#GetLocItemMessage(l:item, l:format)
                            
 3117              0.003482         if l:item.bufnr == -1
                                        " If the buffer number is invalid, remove it.
                                        call remove(l:fixed_item, 'bufnr')
                                    endif
                            
 3117              0.006668         call add(l:new_list, l:fixed_item)
 3117              0.011606     endfor
                            
    4              0.000006     return l:new_list

FUNCTION  ale#engine#IsExecutable()
Called 4 times
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
    4              0.000008     if empty(a:executable)
                                    " Don't log the executable check if the executable string is empty.
                                    return 0
                                endif
                            
                                " Check for a cached executable() check.
    4              0.000017     let l:result = get(s:executable_cache_map, a:executable, v:null)
                            
    4              0.000006     if l:result isnot v:null
    4              0.000004         return l:result
                                endif
                            
                                " Check if the file is executable, and convert -1 to 1.
                                let l:result = executable(a:executable) isnot 0
                            
                                " Cache the executable check if we found it, or if the option to cache
                                " failing checks is on.
                                if l:result || get(g:, 'ale_cache_executable_check_failures', 0)
                                    let s:executable_cache_map[a:executable] = l:result
                                endif
                            
                                if g:ale_history_enabled
                                    call ale#history#Add(a:buffer, l:result, 'executable', a:executable)
                                endif
                            
                                return l:result

FUNCTION  <SNR>92_FormatCurrentLineandIndent()
Called 1 time
Total time:   0.074228
 Self time:   0.027306

count  total (s)   self (s)
    1              0.000001 python3 << endOfPython
                            
                            import time
                            import vim
                            import ZYTFDUAUTOFORMATvimbufferutil
                            
                            line = vim.current.line
                            row, col = vim.current.window.cursor
                            
                            if line.strip() == "":
                                vim.current.line = ""
                                if vim.eval("b:autoformat_lastlength") != "-1":
                                    line = " " * int(vim.eval("b:autoformat_lastlength"))
                                vim.current.buffer.append(line, row)
                                vim.current.window.cursor = (row + 1, len(line))
                            else:
                                vim.command("call s:FormatCurrentLine()")
                                line = vim.current.line
                                row, col = vim.current.window.cursor
                            
                                extra = line.strip()
                            
                                if extra == "":
                                    vim.current.line = ""
                                    vim.current.buffer.append(line, row)
                                    vim.current.window.cursor = (row + 1, len(line))
                                else:
                                    indentlevel, finishflag, unfinishedtype = ZYTFDUAUTOFORMATvimbufferutil.getcurrentindent(vim.current.buffer, row)
                                    if not finishflag:
                                        if unfinishedtype == 6:
                                            nextindentlevel = indentlevel
                                        else:
                                            nextindentlevel = indentlevel + 2
                                    elif vim.current.line[-1] == ":":
                                        nextindentlevel = indentlevel + 1
                                    else:
                                        nextindentlevel = indentlevel
                            
                                    vim.current.buffer.append(" " * (4 * (nextindentlevel)), row)
                                    vim.current.window.cursor = (row + 1, 4 * (nextindentlevel))
                            
                            vim.command("let b:autoformat_lastlength = -1")
                            
                            
                            endOfPython

FUNCTION  ale#Escape()
Called 18 times
Total time:   0.000253
 Self time:   0.000253

count  total (s)   self (s)
   18              0.000072     if fnamemodify(&shell, ':t') is? 'cmd.exe'
                                    " If the string contains spaces, it will be surrounded by quotes.
                                    " Otherwise, special characters will be escaped with carets (^).
                                    return substitute(   a:str =~# ' '       ?  '"' .  substitute(a:str, '"', '""', 'g') . '"'       : substitute(a:str, '\v([&|<>^])', '^\1', 'g'),   '%',   '%%',   'g',)
                                endif
                            
   18              0.000065     return shellescape (a:str)

FUNCTION  ale#util#GetFunction()
Called 2360 times
Total time:   0.014865
 Self time:   0.014865

count  total (s)   self (s)
 2360              0.006299     if type(a:string_or_ref) == type('')
   12              0.000039         return function(a:string_or_ref)
                                endif
                            
 2348              0.002459     return a:string_or_ref

FUNCTION  GetPythonPEPIndent()
Called 1 time
Total time:   0.148893
 Self time:   0.000266

count  total (s)   self (s)
                                " First line has indent 0
    1              0.000010     if a:lnum == 1
                                    return 0
                                endif
                            
    1              0.000011     let line = getline(a:lnum)
    1              0.000011     let prevline = getline(a:lnum-1)
                            
                                " Multilinestrings: continous, docstring or starting.
    1   0.001072   0.000040     if s:is_python_string(a:lnum-1, len(prevline)) && (s:is_python_string(a:lnum, 1)     || match(line, '^\%("""\|''''''\)') != -1)
                            
                                    " Indent closing quotes as the line with the opening ones.
                                    let match_quotes = match(line, '^\s*\zs\%("""\|''''''\)')
                                    if match_quotes != -1
                                        " closing multiline string
                                        let quotes = line[match_quotes:(match_quotes+2)]
                                        let pairpos = searchpairpos(quotes, '', quotes, 'b')
                                        if pairpos[0] != 0
                                            return indent(pairpos[0])
                                        else
                                            " TODO: test to cover this!
                                        endif
                                    endif
                            
                                    if s:is_python_string(a:lnum-1)
                                        " Previous line is (completely) a string.
                                        return indent(a:lnum-1)
                                    endif
                            
                                    if match(prevline, '^\s*\%("""\|''''''\)') != -1
                                        " docstring.
                                        return indent(a:lnum-1)
                                    endif
                            
                                    let indent_multi = get(b:, 'python_pep8_indent_multiline_string', get(g:, 'python_pep8_indent_multiline_string', 0))
                                    if match(prevline, '\v%("""|'''''')$') != -1
                                        " Opening multiline string, started in previous line.
                                        if (&autoindent && indent(a:lnum) == indent(a:lnum-1)) || match(line, '\v^\s+$') != -1
                                            " <CR> with empty line or to split up 'foo("""bar' into
                                            " 'foo("""' and 'bar'.
                                            if indent_multi == -2
                                                return indent(a:lnum-1) + s:sw()
                                            endif
                                            return indent_multi
                                        endif
                                    endif
                            
                                    " Keep existing indent.
                                    if match(line, '\v^\s*\S') != -1
                                        return -1
                                    endif
                            
                                    if indent_multi != -2
                                        return indent_multi
                                    endif
                            
                                    return s:indent_like_opening_paren(a:lnum)
                                endif
                            
                                " Parens: If we can find an open parenthesis/bracket/brace, line up with it.
    1   0.077183   0.000037     let indent = s:indent_like_opening_paren(a:lnum)
    1              0.000001     if indent >= -1
                                    return indent
                                endif
                            
                                " Blocks: Match indent of first block of this type.
    1   0.000103   0.000008     let indent = s:indent_like_block(a:lnum)
    1              0.000001     if indent >= -1
                                    return indent
                                endif
                            
    1   0.070362   0.000008     return s:indent_like_previous_line(a:lnum)

FUNCTION  <SNR>109_ale_refresh()
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000008   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh'
                              endif

FUNCTION  <SNR>142_DisableOnLargeFile()
Called 158 times
Total time:   0.001355
 Self time:   0.001355

count  total (s)   self (s)
  158              0.000781   if exists( 'b:ycm_largefile' )
  158              0.000331     return b:ycm_largefile
                              endif
                            
                              let threshold = g:ycm_disable_for_files_larger_than_kb * 1024
                              let b:ycm_largefile = threshold > 0 && getfsize( expand( a:buffer ) ) > threshold
                              if b:ycm_largefile
                                exec s:python_command "vimsupport.PostVimMessage(" . "'YouCompleteMe is disabled in this buffer; " . "the file exceeded the max size (see YCM options).' )"
                              endif
                              return b:ycm_largefile

FUNCTION  <SNR>134_FindHistoryItem()
Called 8 times
Total time:   0.000228
 Self time:   0.000134

count  total (s)   self (s)
                                " Search backwards to find a matching job ID. IDs might be recycled,
                                " so finding the last one should be good enough.
   10   0.000162   0.000068     for l:obj in reverse(ale#history#Get(a:buffer))
   10              0.000022         if l:obj.job_id == a:job_id
    8              0.000009             return l:obj
                                    endif
    2              0.000002     endfor
                            
                                return {}

FUNCTION  <SNR>148_ShouldOpen()
Called 7 times
Total time:   0.000243
 Self time:   0.000088

count  total (s)   self (s)
    7   0.000197   0.000042     let l:val = ale#Var(a:buffer, 'open_list')
    7              0.000022     let l:saved = getbufvar(a:buffer, 'ale_save_event_fired', 0)
                            
    7              0.000014     return l:val is 1 || (l:val is# 'on_save' && l:saved)

FUNCTION  delimitMate#WithinEmptyPair()
Called 1 time
Total time:   0.000184
 Self time:   0.000065

count  total (s)   self (s)
                              " if cursor is at column 1 return 0
    1              0.000006   if col('.') == 1
                                return 0
                              endif
                              " get char before the cursor.
    1   0.000087   0.000021   let char1 = s:get_char(-1)
                              " get char under the cursor.
    1   0.000042   0.000009   let char2 = s:get_char(0)
    1   0.000040   0.000020   return delimitMate#IsEmptyPair( char1.char2 )

FUNCTION  <SNR>68_EnoughTimePassed()
Called 107 times
Total time:   0.001532
 Self time:   0.001532

count  total (s)   self (s)
  107              0.000455         let prev = a:last.last_heartbeat_at
  107              0.000545         if a:now - prev > g:wakatime_HeartbeatFrequency * 60
                                        return s:true
                                    endif
  107              0.000154         return s:false

FUNCTION  <SNR>146_CreateCountDict()
Called 4 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
                                " Keys 0 and 1 are for backwards compatibility.
                                " The count object used to be a List of [error_count, warning_count].
    4              0.000021     return {   '0': 0,   '1': 0,   'error': 0,   'warning': 0,   'info': 0,   'style_error': 0,   'style_warning': 0,   'total': 0,}

FUNCTION  airline#parts#ffenc()
Called 179 times
Total time:   0.004225
 Self time:   0.004225

count  total (s)   self (s)
  179              0.000671   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
  179              0.000297   let bomb     = &l:bomb ? '[BOM]' : ''
  179              0.001463   let ff       = strlen(&ff) ? '['.&ff.']' : ''
  179              0.000809   if expected is# &fenc.bomb.ff
                                return ''
                              else
  179              0.000523     return &fenc.bomb.ff
                              endif

FUNCTION  <SNR>142_OnTextChangedInsertMode()
Called 47 times
Total time:   0.127909
 Self time:   0.022951

count  total (s)   self (s)
   47   0.002362   0.000198   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
   47              0.000048   if s:completion_stopped
                                let s:completion_stopped = 0
                                let s:completion = s:default_completion
                                return
                              endif
                            
   47   0.018005   0.000200   call s:IdentifierFinishedOperations()
                            
                              " We have to make sure we correctly leave semantic mode even when the user
                              " inserts something like a "operator[]" candidate string which fails
                              " CurrentIdentifierFinished check.
   47              0.000160   if s:force_semantic && !s:Pyeval( 'base.LastEnteredCharIsIdentifierChar()' )
                                let s:force_semantic = 0
                              endif
                            
   47   0.013987   0.000917   if &completefunc == "youcompleteme#CompleteFunc" && ( g:ycm_auto_trigger || s:force_semantic ) && !s:InsideCommentOrStringAndShouldStop() && !s:OnBlankLine()
                                " Immediately call previous completion to avoid flickers.
   45   0.001321   0.000279     call s:Complete()
   45   0.071060   0.000183     call s:InvokeCompletion()
   45              0.000045   endif
                            
   47              0.019870   exec s:python_command "ycm_state.OnCursorMoved()"
                            
   47              0.000167   if g:ycm_autoclose_preview_window_after_completion
                                call s:ClosePreviewWindowIfNeeded()
                              endif

FUNCTION  ale#linter#GetCommand()
Called 4 times
Total time:   0.013827
 Self time:   0.000053

count  total (s)   self (s)
    4   0.013821   0.000047     return has_key(a:linter, 'command_callback')   ? ale#util#GetFunction(a:linter.command_callback)(a:buffer)   : a:linter.command

FUNCTION  <SNR>115_get_syn()
Called 1132 times
Total time:   0.036723
 Self time:   0.036723

count  total (s)   self (s)
 1132              0.003778   if !exists("g:airline_gui_mode")
                                let g:airline_gui_mode = airline#init#gui_mode()
                              endif
 1132              0.001532   let color = ''
 1132              0.003436   if hlexists(a:group)
 1132              0.007197     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, g:airline_gui_mode)
 1132              0.000897   endif
 1132              0.002940   if empty(color) || color == -1
                                " should always exists
                                let color = synIDattr(synIDtrans(hlID('Normal')), a:what, g:airline_gui_mode)
                                " however, just in case
                                if empty(color) || color == -1
                                  let color = 'NONE'
                                endif
                              endif
 1132              0.001727   return color

FUNCTION  airline#util#ignore_buf()
Called 179 times
Total time:   0.003530
 Self time:   0.003530

count  total (s)   self (s)
  179              0.001354   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat',  'gundo|undotree|vimfiler|tagbar|nerd_tree|startify')
  179              0.002043   return match(a:name, pat) > -1

FUNCTION  <SNR>131_StopCurrentJobs()
Called 3 times
Total time:   0.000246
 Self time:   0.000246

count  total (s)   self (s)
    3              0.000021     let l:info = get(g:ale_buffer_info, a:buffer, {})
    3              0.000009     let l:new_job_list = []
    3              0.000010     let l:new_active_linter_list = []
                            
    3              0.000023     for l:job_id in get(l:info, 'job_list', [])
                                    let l:job_info = get(s:job_info_map, l:job_id, {})
                            
                                    if !empty(l:job_info)
                                        if a:include_lint_file_jobs || !l:job_info.linter.lint_file
                                            call ale#job#Stop(l:job_id)
                                            call remove(s:job_info_map, l:job_id)
                                        else
                                            call add(l:new_job_list, l:job_id)
                                            " Linters with jobs still running are still active.
                                            call add(l:new_active_linter_list, l:job_info.linter.name)
                                        endif
                                    endif
                                endfor
                            
                                " Remove duplicates from the active linter list.
    3              0.000035     call uniq(sort(l:new_active_linter_list))
                            
                                " Update the List, so it includes only the jobs we still need.
    3              0.000011     let l:info.job_list = l:new_job_list
                                " Update the active linter list, clearing out anything not running.
    3              0.000011     let l:info.active_linter_list = l:new_active_linter_list

FUNCTION  <SNR>77_Highlight_Matching_Pair()
Called 155 times
Total time:   0.016571
 Self time:   0.016571

count  total (s)   self (s)
                              " Remove any previous match.
  155              0.000723   if exists('w:paren_hl_on') && w:paren_hl_on
    4              0.000084     silent! call matchdelete(3)
    4              0.000010     let w:paren_hl_on = 0
    4              0.000004   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  155              0.000801   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  155              0.000493   let c_lnum = line('.')
  155              0.000471   let c_col = col('.')
  155              0.000198   let before = 0
                            
  155              0.000500   let text = getline(c_lnum)
  155              0.002521   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
  155              0.000375   if empty(matches)
                                let [c_before, c] = ['', '']
                              else
  155              0.000812     let [c_before, c] = matches[1:2]
  155              0.000120   endif
  155              0.001365   let plist = split(&matchpairs, '.\zs[:,]')
  155              0.000517   let i = index(plist, c)
  155              0.000184   if i < 0
                                " not found, in Insert mode try character before the cursor
  150              0.000544     if c_col > 1 && (mode() == 'i' || mode() == 'R')
   90              0.000211       let before = strlen(c_before)
   90              0.000106       let c = c_before
   90              0.000175       let i = index(plist, c)
   90              0.000059     endif
  150              0.000171     if i < 0
                                  " not found, nothing to do
  150              0.000149       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
    5              0.000005   if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
    5              0.000007     let s_flags = 'nbW'
    5              0.000005     let c2 = c
    5              0.000010     let c = plist[i - 1]
    5              0.000003   endif
    5              0.000005   if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
    5              0.000004   if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              " Build an expression that detects whether the current cursor position is in
                              " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
                              " skip argument.
                              " We match "escape" for special items, such as lispEscapeSpecial.
    5              0.000017   let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                              " If executing the expression determines that the cursor is currently in
                              " one of the syntax types, then we want searchpairpos() to find the pair
                              " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                              " outside of the syntax types and s_skip should keep its value so we skip any
                              " matching pair inside the syntax types.
    5              0.001033   execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
    5              0.000013   let stoplinebottom = line('w$')
    5              0.000011   let stoplinetop = line('w0')
    5              0.000005   if i % 2 == 0
                                let stopline = stoplinebottom
                              else
    5              0.000009     let stopline = stoplinetop
    5              0.000003   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
    5              0.000011   if mode() == 'i' || mode() == 'R'
    4              0.000018     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
    4              0.000001   else
    1              0.000004     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
    1              0.000000   endif
    5              0.000004   try
    5              0.001051     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
    5              0.000007   catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
    5              0.000005   if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
    5              0.000011   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
    5              0.000011     if exists('*matchaddpos')
    5              0.000154       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
    5              0.000003     else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
    5              0.000009     let w:paren_hl_on = 1
    5              0.000003   endif

FUNCTION  <SNR>68_SetLastHeartbeat()
Called 1 time
Total time:   0.001705
 Self time:   0.001575

count  total (s)   self (s)
    1   0.000219   0.000174         call s:SetLastHeartbeatInMemory(a:last_activity_at, a:last_heartbeat_at, a:file)
    1   0.001482   0.001397         call writefile([s:n2s(a:last_activity_at), s:n2s(a:last_heartbeat_at), a:file], s:data_file)

FUNCTION  <SNR>92_ExitInsertMode()
Called 2 times
Total time:   0.001045
 Self time:   0.001045

count  total (s)   self (s)
    2              0.000004 python3 << endOfPython
                            
                            row, col = vim.current.window.cursor
                            
                            if vim.current.line.strip() == "":
                                vim.current.window.cursor = (row, 1)
                                vim.current.line = ""
                            
                            endOfPython

FUNCTION  airline#parts#paste()
Called 179 times
Total time:   0.000471
 Self time:   0.000471

count  total (s)   self (s)
  179              0.000403   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  ale#util#BinarySearch()
Called 61 times
Total time:   0.021419
 Self time:   0.021419

count  total (s)   self (s)
   61              0.000088     let l:min = 0
   61              0.000221     let l:max = len(a:loclist) - 1
                            
  671              0.000455     while 1
  671              0.000711         if l:max < l:min
   61              0.000049             return -1
                                    endif
                            
  610              0.001017         let l:mid = (l:min + l:max) / 2
  610              0.001335         let l:item = a:loclist[l:mid]
                            
                                    " Binary search for equal buffers, equal lines, then near columns.
  610              0.000786         if l:item.bufnr < a:buffer
                                        let l:min = l:mid + 1
                                    elseif l:item.bufnr > a:buffer
                                        let l:max = l:mid - 1
                                    elseif l:item.lnum < a:line
  610              0.000809             let l:min = l:mid + 1
  610              0.000548         elseif l:item.lnum > a:line
                                        let l:max = l:mid - 1
                                    else
                                        " This part is a small sequential search.
                                        let l:index = l:mid
                            
                                        " Search backwards to find the first problem on the line.
                                        while l:index > 0&& a:loclist[l:index - 1].bufnr == a:buffer&& a:loclist[l:index - 1].lnum == a:line
                                            let l:index -= 1
                                        endwhile
                            
                                        " Find the last problem on or before this column.
                                        while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col <= a:column
                                            let l:index += 1
                                        endwhile
                            
                                        " Scan forwards to find the last item on the column for the item
                                        " we found, which will have the most serious problem.
                                        let l:item_column = a:loclist[l:index].col
                            
                                        while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col == l:item_column
                                            let l:index += 1
                                        endwhile
                            
                                        return l:index
                                    endif
  610              0.000447     endwhile

FUNCTION  <SNR>18_TriggerAbb()
Called 1 time
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    1              0.000023   if v:version < 703 || ( v:version == 703 && !has('patch489') ) || pumvisible()
                                return ''
                              endif
    1              0.000006   return "\<C-]>"

FUNCTION  ale#events#SaveEvent()
Called 1 time
Total time:   0.026435
 Self time:   0.000128

count  total (s)   self (s)
    1   0.000031   0.000007     let l:should_lint = ale#Var(a:buffer, 'enabled') && g:ale_lint_on_save
                            
    1              0.000001     if l:should_lint
    1              0.000003         call setbufvar(a:buffer, 'ale_save_event_fired', 1)
    1              0.000001     endif
                            
    1   0.000037   0.000018     if ale#Var(a:buffer, 'fix_on_save')
                                    let l:will_fix = ale#fix#Fix(a:buffer, 'save_file')
                                    let l:should_lint = l:should_lint && !l:will_fix
                                endif
                            
    1   0.000010   0.000004     if l:should_lint && !ale#events#QuitRecently(a:buffer)
    1   0.026339   0.000081         call ale#Queue(0, 'lint_file', a:buffer)
    1              0.000002     endif

FUNCTION  airline#parts#readonly()
Called 179 times
Total time:   0.006723
 Self time:   0.003193

count  total (s)   self (s)
                              " only consider regular buffers (e.g. ones that represent actual files, 
                              " but not special ones like e.g. NERDTree)
  179   0.005073   0.001543   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
                                return ''
                              endif
  179              0.000422   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
                              else
  179              0.000300     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  ale#sign#ParseSigns()
Called 4 times
Total time:   0.098050
 Self time:   0.098050

count  total (s)   self (s)
                                " Matches output like :
                                " line=4  id=1  name=ALEErrorSign
                                " строка=1  id=1000001  имя=ALEErrorSign
                                " 行=1  識別子=1000001  名前=ALEWarningSign
                                " línea=12 id=1000001 nombre=ALEWarningSign
                                " riga=1 id=1000001, nome=ALEWarningSign
    4              0.000012     let l:pattern = '\v^.*\=(\d+).*\=(\d+).*\=(ALE[a-zA-Z]+Sign)'
    4              0.000005     let l:result = []
    4              0.000005     let l:is_dummy_sign_set = 0
                            
 3132              0.003549     for l:line in a:line_list
 3128              0.044854         let l:match = matchlist(l:line, l:pattern)
                            
 3128              0.005428         if len(l:match) > 0
 3120              0.005911             if l:match[3] is# 'ALEDummySign'
    4              0.000004                 let l:is_dummy_sign_set = 1
    4              0.000003             else
 3116              0.016668                 call add(l:result, [   str2nr(l:match[1]),   str2nr(l:match[2]),   l:match[3],])
 3116              0.001861             endif
 3120              0.001742         endif
 3128              0.010776     endfor
                            
    4              0.000012     return [l:is_dummy_sign_set, l:result]

FUNCTION  UltiSnips#TrackChange()
Called 95 times
Total time:   0.021601
 Self time:   0.021601

count  total (s)   self (s)
   95              0.021454     exec g:_uspy "UltiSnips_Manager._track_change()"

FUNCTION  ale#util#GetItemPriority()
Called 3117 times
Total time:   0.032675
 Self time:   0.032675

count  total (s)   self (s)
 3117              0.004262     if a:item.type is# 'I'
                                    return g:ale#util#info_priority
                                endif
                            
 3117              0.003271     if a:item.type is# 'W'
 3116              0.007604         if get(a:item, 'sub_type', '') is# 'style'
                                        return g:ale#util#style_warning_priority
                                    endif
                            
 3116              0.003335         return g:ale#util#warning_priority
                                endif
                            
    1              0.000003     if get(a:item, 'sub_type', '') is# 'style'
                                    return g:ale#util#style_error_priority
                                endif
                            
    1              0.000001     return g:ale#util#error_priority

FUNCTION  ale#engine#RunLinters()
Called 3 times
Total time:   0.066003
 Self time:   0.001385

count  total (s)   self (s)
                                " Initialise the buffer information if needed.
    3   0.000094   0.000030     let l:new_buffer = ale#engine#InitBufferInfo(a:buffer)
    3   0.000283   0.000037     call s:StopCurrentJobs(a:buffer, a:should_lint_file)
    3   0.007702   0.000056     call s:RemoveProblemsForDisabledLinters(a:buffer, a:linters)
                            
                                " We can only clear the results if we aren't checking the buffer.
    3   0.000081   0.000042     let l:can_clear_results = !ale#engine#IsCheckingBuffer(a:buffer)
                            
    3   0.000196   0.000162     silent doautocmd <nomodeline> User ALELintPre
                            
    9              0.000042     for l:linter in a:linters
                                    " Only run lint_file linters if we should.
    6              0.000017         if !l:linter.lint_file || a:should_lint_file
    4   0.057309   0.000720             if s:RunLinter(a:buffer, l:linter)
                                            " If a single linter ran, we shouldn't clear everything.
    4              0.000024                 let l:can_clear_results = 0
    4              0.000005             endif
    4              0.000003         else
                                        " If we skipped running a lint_file linter still in the list,
                                        " we shouldn't clear everything.
    2              0.000003             let l:can_clear_results = 0
    2              0.000000         endif
    6              0.000017     endfor
                            
                                " Clear the results if we can. This needs to be done when linters are
                                " disabled, or ALE itself is disabled.
    3              0.000004     if l:can_clear_results
                                    call ale#engine#SetResults(a:buffer, [])
                                elseif l:new_buffer
                                    call s:AddProblemsFromOtherBuffers(a:buffer, a:linters)
                                endif

FUNCTION  <SNR>115_exec_separator()
Called 63 times
Total time:   0.036977
 Self time:   0.003067

count  total (s)   self (s)
   63              0.000142   if pumvisible()
                                return
                              endif
   63   0.009346   0.000494   let l:from = airline#themes#get_highlight(a:from.a:suffix)
   63   0.009011   0.000460   let l:to = airline#themes#get_highlight(a:to.a:suffix)
   63              0.000241   let group = a:from.'_to_'.a:to.a:suffix
   63              0.000084   if a:inverse
   18              0.000101     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
   18              0.000016   else
   45              0.000245     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
   45              0.000038   endif
   63              0.000321   let a:dict[group] = colors
   63   0.017041   0.000534   call airline#highlighter#exec(group, colors)

FUNCTION  <SNR>142_OnInsertLeave()
Called 2 times
Total time:   0.012297
 Self time:   0.006451

count  total (s)   self (s)
    2   0.000189   0.000020   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
    2              0.000012   call timer_stop( s:pollers.completion.id )
    2              0.000007   let s:force_semantic = 0
    2              0.000013   let s:completion = s:default_completion
                            
    2   0.005700   0.000023   call s:OnFileReadyToParse()
    2              0.006323   exec s:python_command "ycm_state.OnInsertLeave()"
    2              0.000022   if g:ycm_autoclose_preview_window_after_completion || g:ycm_autoclose_preview_window_after_insertion
                                call s:ClosePreviewWindowIfNeeded()
                              endif

FUNCTION  airline#highlighter#exec()
Called 440 times
Total time:   0.123002
 Self time:   0.039334

count  total (s)   self (s)
  440              0.001001   if pumvisible()
                                return
                              endif
  440              0.000763   let colors = a:colors
  440              0.000569   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
                              endif
  440   0.064289   0.003185   let old_hi = airline#highlighter#get_highlight(a:group)
  440              0.001059   if len(colors) == 4
   63              0.000180     call add(colors, '')
   63              0.000045   endif
  440              0.000815   if g:airline_gui_mode ==# 'gui'
  440              0.002459     let new_hi = [colors[0], colors[1], '', '', colors[4]]
  440              0.000366   else
                                let new_hi = ['', '', printf("%s", colors[2]), printf("%s", colors[3]), colors[4]]
                              endif
  440   0.015321   0.002547   let colors = s:CheckDefined(colors)
  440   0.006962   0.002757   if old_hi != new_hi || !s:hl_group_exists(a:group)
  110   0.009474   0.003889     let cmd = printf('hi %s %s %s %s %s %s %s %s', a:group, s:Get(colors, 0, 'guifg='), s:Get(colors, 1, 'guibg='), s:Get(colors, 2, 'ctermfg='), s:Get(colors, 3, 'ctermbg='), s:Get(colors, 4, 'gui='), s:Get(colors, 4, 'cterm='), s:Get(colors, 4, 'term='))
  110              0.003164     exe cmd
  110              0.000510     if has_key(s:hl_groups, a:group)
  110              0.000332       let s:hl_groups[a:group] = colors
  110              0.000089     endif
  110              0.000065   endif

FUNCTION  airline#extensions#whitespace#check()
Called 179 times
Total time:   0.083416
 Self time:   0.030766

count  total (s)   self (s)
  179              0.000750   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
  179              0.001177   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
                              endif
  179              0.001042   let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                            
  179              0.000575   if !exists('b:airline_whitespace_check')
    1              0.000011     let b:airline_whitespace_check = ''
    1              0.000049     let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
    1              0.000005     let trailing = 0
    1              0.000003     let check = 'trailing'
    1              0.000036     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    1              0.000005       try
    1              0.000009         let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
    1              0.012847         let trailing = search(regexp, 'nw')
    1              0.000006       catch
                                    echomsg 'airline#whitespace: error occurred evaluating '. regexp
                                    echomsg v:exception
                                    return ''
                                  endtry
    1              0.000001     endif
                            
    1              0.000004     let mixed = 0
    1              0.000002     let check = 'indent'
    1              0.000019     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    1   0.033328   0.000018       let mixed = s:check_mixed_indent()
    1              0.000004     endif
                            
    1              0.000003     let mixed_file = ''
    1              0.000002     let check = 'mixed-indent-file'
    1              0.000018     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    1   0.016780   0.000021       let mixed_file = s:check_mixed_indent_file()
    1              0.000001     endif
                            
    1              0.000002     let long = 0
    1              0.000005     if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
                                endif
                            
    1              0.000005     if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file)
                                  let b:airline_whitespace_check = s:symbol
                                  if strlen(s:symbol) > 0
                                    let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
                                  endif
                            
                                  if s:show_message
                                    if trailing != 0
                                      let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
                                      let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
                                    endif
                                    if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
                                    if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
                                    if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
                                  endif
                                endif
    1              0.000001   endif
  179   0.003546   0.000965   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  <SNR>109_airline_ale_count()
Called 358 times
Total time:   0.000833
 Self time:   0.000833

count  total (s)   self (s)
  358              0.000731   return a:cnt ? a:symbol. a:cnt : ''

FUNCTION  ale#path#CdString()
Called 4 times
Total time:   0.000115
 Self time:   0.000044

count  total (s)   self (s)
    4   0.000112   0.000041     return 'cd ' . ale#Escape(a:directory) . ' && '

FUNCTION  <SNR>122_GetAliasedFiletype()
Called 6 times
Total time:   0.000449
 Self time:   0.000449

count  total (s)   self (s)
    6              0.000038     let l:buffer_aliases = get(b:, 'ale_linter_aliases', {})
                            
                                " b:ale_linter_aliases can be set to a List.
    6              0.000034     if type(l:buffer_aliases) is type([])
                                    return l:buffer_aliases
                                endif
                            
                                " Check for aliased filetypes first in a buffer variable,
                                " then the global variable,
                                " then in the default mapping,
                                " otherwise use the original filetype.
   24              0.000090     for l:dict in [   l:buffer_aliases,   g:ale_linter_aliases,   s:default_ale_linter_aliases,]
   18              0.000074         if has_key(l:dict, a:original_filetype)
                                        return l:dict[a:original_filetype]
                                    endif
   18              0.000022     endfor
                            
    6              0.000014     return a:original_filetype

FUNCTION  <SNR>142_AllowedToCompleteInBuffer()
Called 158 times
Total time:   0.011365
 Self time:   0.010010

count  total (s)   self (s)
  158              0.001619   let buffer_filetype = getbufvar( a:buffer, '&filetype' )
                            
  158              0.001542   if empty( buffer_filetype ) || getbufvar( a:buffer, '&buftype' ) ==# 'nofile' || buffer_filetype ==# 'qf'
                                return 0
                              endif
                            
  158   0.002474   0.001119   if s:DisableOnLargeFile( a:buffer )
                                return 0
                              endif
                            
  158              0.001395   let whitelist_allows = has_key( g:ycm_filetype_whitelist, '*' ) || has_key( g:ycm_filetype_whitelist, buffer_filetype )
  158              0.000789   let blacklist_allows = !has_key( g:ycm_filetype_blacklist, buffer_filetype )
                            
  158              0.000444   let allowed = whitelist_allows && blacklist_allows
  158              0.000251   if allowed
  158              0.000821     let s:previous_allowed_buffer_number = bufnr( a:buffer )
  158              0.000160   endif
  158              0.000238   return allowed

FUNCTION  <SNR>136_VimExitCallback()
Called 4 times
Total time:   0.590564
 Self time:   0.000342

count  total (s)   self (s)
    4   0.000062   0.000035     let l:job_id = ale#job#ParseVim8ProcessID(string(a:job))
    4              0.000016     let l:info = get(s:job_map, l:job_id, {})
                            
    4              0.000009     if empty(l:info)
                                    return
                                endif
                            
    4              0.000012     let l:info.exit_code = a:exit_code
                            
                                " The program can exit before the data has finished being read.
    4              0.000019     if ch_status(job_getchannel(a:job)) is# 'closed'
    3              0.000004         try
    3              0.000013             if !empty(l:info) && has_key(l:info, 'exit_cb')
    3   0.590277   0.000082                 call ale#util#GetFunction(l:info.exit_cb)(l:job_id, a:exit_code)
    3              0.000002             endif
    3              0.000027         finally
                                        " Automatically forget about the job after it's done.
    3              0.000057             if has_key(s:job_map, l:job_id)
    3              0.000013                 call remove(s:job_map, l:job_id)
    3              0.000002             endif
    3              0.000004         endtry
    3              0.000001     endif

FUNCTION  <SNR>19_is_space_expansion()
Called 1 time
Total time:   0.000352
 Self time:   0.000109

count  total (s)   self (s)
    1              0.000006   if col('.') > 2
    1   0.000065   0.000010     let pchar = s:get_char(-2)
    1   0.000037   0.000007     let nchar = s:get_char(1)
    1   0.000111   0.000032     let isSpaces = (s:get_char(-1)   == s:get_char(0) && s:get_char(-1) == " ")
                            
    1   0.000064   0.000021     if index(s:get('left_delims'), pchar) > -1 && index(s:get('left_delims'), pchar)   == index(s:get('right_delims'), nchar) && isSpaces
                                  return 1
                                elseif index(s:get('quotes_list'), pchar) > -1 && index(s:get('quotes_list'), pchar)   == index(s:get('quotes_list'), nchar) && isSpaces
                                  return 1
                                endif
    1              0.000002   endif
    1              0.000001   return 0

FUNCTION  ale#util#StartPartialTimer()
Called 2 times
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    2              0.000014     let l:timer_id = timer_start(a:delay, function('s:ApplyPartialTimer'))
    2              0.000011     let s:partial_timers[l:timer_id] = [a:callback, a:args]
                            
    2              0.000002     return l:timer_id

FUNCTION  <SNR>109_airline_ale_get_line_number()
Called 358 times
Total time:   0.192840
 Self time:   0.191535

count  total (s)   self (s)
  358              0.000386   if a:cnt == 0
  179              0.000138     return ''
                              endif
                            
  179              0.000360   let buffer       = bufnr('')
  179              0.000455   let problem_type = (a:type ==# 'error') ? 'E' : 'W'
  179   0.023967   0.022662   let problems     = copy(ale#engine#GetLoclist(buffer))
                            
  179              0.163116   call filter(problems, 'v:val.bufnr is buffer && v:val.type is# problem_type')
                            
  179              0.000549   if empty(problems)
                                return ''
                              endif
                            
  179              0.000836   let open_lnum_symbol  = get(g:, 'airline#extensions#ale#open_lnum_symbol', '(L')
  179              0.000653   let close_lnum_symbol = get(g:, 'airline#extensions#ale#close_lnum_symbol', ')')
                            
  179              0.000875   return open_lnum_symbol . problems[0].lnum . close_lnum_symbol

FUNCTION  <SNR>142_IdentifierFinishedOperations()
Called 47 times
Total time:   0.017805
 Self time:   0.014425

count  total (s)   self (s)
   47   0.003588   0.000208   if !s:Pyeval( 'base.CurrentIdentifierFinished()' )
   39              0.000043     return
                              endif
    8              0.014035   exec s:python_command "ycm_state.OnCurrentIdentifierFinished()"
    8              0.000048   let s:force_semantic = 0
    8              0.000029   let s:completion = s:default_completion

FUNCTION  ale#util#LocItemCompare()
Called 9552 times
Total time:   0.149715
 Self time:   0.149715

count  total (s)   self (s)
 9552              0.010226     if a:left.bufnr < a:right.bufnr
                                    return -1
                                endif
                            
 9552              0.009805     if a:left.bufnr > a:right.bufnr
                                    return 1
                                endif
                            
 9552              0.007883     if a:left.bufnr == -1
                                    if a:left.filename < a:right.filename
                                        return -1
                                    endif
                            
                                    if a:left.filename > a:right.filename
                                        return 1
                                    endif
                                endif
                            
 9552              0.010295     if a:left.lnum < a:right.lnum
 2897              0.001876         return -1
                                endif
                            
 6655              0.007058     if a:left.lnum > a:right.lnum
 6655              0.004500         return 1
                                endif
                            
                                if a:left.col < a:right.col
                                    return -1
                                endif
                            
                                if a:left.col > a:right.col
                                    return 1
                                endif
                            
                                " When either of the items lacks a problem type, then the two items should
                                " be considered equal. This is important for loclist jumping.
                                if !has_key(a:left, 'type') || !has_key(a:right, 'type')
                                    return 0
                                endif
                            
                                let l:left_priority = ale#util#GetItemPriority(a:left)
                                let l:right_priority = ale#util#GetItemPriority(a:right)
                            
                                if l:left_priority < l:right_priority
                                    return -1
                                endif
                            
                                if l:left_priority > l:right_priority
                                    return 1
                                endif
                            
                                return 0

FUNCTION  <SNR>56_on_window_changed()
Called 43 times
Total time:   0.002921
 Self time:   0.002921

count  total (s)   self (s)
   43              0.000386   let s:active_winnr = winnr()
                            
   43              0.000195   if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
                                return
                              endif
                              " Handle each window only once, since we might come here several times for
                              " different autocommands.
   43              0.000812   let l:key = [bufnr('%'), s:active_winnr, winnr('$'), tabpagenr(), &ft]
   43              0.000994   if get(g:, 'airline_last_window_changed', []) == l:key && &stl is# '%!airline#statusline('.s:active_winnr.')' && &ft !~? 'gitcommit'
                                " fugitive is special, it changes names and filetypes several times,
                                " make sure the caching does not get into its way
   43              0.000085     return
                              endif
                              let g:airline_last_window_changed = l:key
                              call s:init()
                              call airline#update_statusline()

FUNCTION  <SNR>142_Complete()
Called 86 times
Total time:   0.002583
 Self time:   0.001932

count  total (s)   self (s)
                              " Do not call user's completion function if the start column is after the
                              " current column or if there are no candidates. Close the completion menu
                              " instead. This avoids keeping the user in completion mode.
   86              0.000559   if s:completion.start_column > col( '.' ) || empty( s:completion.candidates )
   43   0.000585   0.000258     call s:CloseCompletionMenu()
   43              0.000038   else
                                " <c-x><c-u> invokes the user's completion function (which we have set to
                                " youcompleteme#CompleteFunc), and <c-p> tells Vim to select the previous
                                " completion candidate. This is necessary because by default, Vim selects the
                                " first candidate when completion is invoked, and selecting a candidate
                                " automatically replaces the current text with it. Calling <c-p> forces Vim to
                                " deselect the first candidate and in turn preserve the user's current text
                                " until he explicitly chooses to replace it with a completion.
   43   0.000611   0.000287     call s:SendKeys( "\<C-X>\<C-U>\<C-P>" )
   43              0.000024   endif

FUNCTION  ale#history#SetExitCode()
Called 4 times
Total time:   0.000199
 Self time:   0.000054

count  total (s)   self (s)
    4   0.000177   0.000032     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
                                " If we find a match, then set the code and status.
    4              0.000009     let l:obj.exit_code = a:exit_code
    4              0.000009     let l:obj.status = 'finished'

FUNCTION  <SNR>148_CloseWindowIfNeeded()
Called 3 times
Total time:   0.000169
 Self time:   0.000029

count  total (s)   self (s)
    3   0.000165   0.000025     if ale#Var(a:buffer, 'keep_list_window_open') || !s:ShouldOpen(a:buffer)
    3              0.000001         return
                                endif
                            
                                try
                                    " Only close windows if the quickfix list or loclist is completely empty,
                                    " including errors set through other means.
                                    if g:ale_set_quickfix
                                        if empty(getqflist())
                                            cclose
                                        endif
                                    else
                                        let l:win_id = s:BufWinId(a:buffer)
                            
                                        if g:ale_set_loclist && empty(getloclist(l:win_id))
                                            lclose
                                        endif
                                    endif
                                " Ignore 'Cannot close last window' errors.
                                catch /E444/
                                endtry

FUNCTION  <SNR>148_BufWinId()
Called 4 times
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    4              0.000030     return exists('*bufwinid') ? bufwinid(str2nr(a:buffer)) : 0

FUNCTION  <SNR>143_FindItemAtCursor()
Called 61 times
Total time:   0.023411
 Self time:   0.001992

count  total (s)   self (s)
   61              0.000165     let l:buf = bufnr('')
   61              0.000432     let l:info = get(g:ale_buffer_info, l:buf, {})
   61              0.000229     let l:loclist = get(l:info, 'loclist', [])
   61              0.000190     let l:pos = getcurpos()
   61   0.021961   0.000542     let l:index = ale#util#BinarySearch(l:loclist, l:buf, l:pos[1], l:pos[2])
   61              0.000157     let l:loc = l:index >= 0 ? l:loclist[l:index] : {}
                            
   61              0.000100     return [l:info, l:loc]

FUNCTION  ale#statusline#Update()
Called 4 times
Total time:   0.041883
 Self time:   0.041855

count  total (s)   self (s)
    4              0.000017     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
                                    return
                                endif
                            
    4              0.001772     let l:loclist = filter(copy(a:loclist), 'v:val.bufnr == a:buffer')
    4   0.000050   0.000022     let l:count = s:CreateCountDict()
    4              0.000011     let l:count.total = len(l:loclist)
                            
 3121              0.002361     for l:entry in l:loclist
 3117              0.003433         if l:entry.type is# 'W'
 3116              0.006341             if get(l:entry, 'sub_type', '') is# 'style'
                                            let l:count.style_warning += 1
                                        else
 3116              0.003113                 let l:count.warning += 1
 3116              0.001491             endif
 3116              0.002520         elseif l:entry.type is# 'I'
                                        let l:count.info += 1
                                    elseif get(l:entry, 'sub_type', '') is# 'style'
                                        let l:count.style_error += 1
                                    else
    1              0.000001             let l:count.error += 1
    1              0.000001         endif
 3117              0.002057     endfor
                            
                                " Set keys for backwards compatibility.
    4              0.000020     let l:count[0] = l:count.error + l:count.style_error
    4              0.000009     let l:count[1] = l:count.total - l:count[0]
                            
    4              0.000030     let g:ale_buffer_info[a:buffer].count = l:count

FUNCTION  airline#parts#spell()
Called 179 times
Total time:   0.004304
 Self time:   0.004304

count  total (s)   self (s)
  179              0.001951   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
  179              0.000280   if g:airline_detect_spell && &spell
                                if winwidth(0) >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth(0) >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
                              endif
  179              0.000133   return ''

FUNCTION  ale#Lint()
Called 3 times
Total time:   0.068918
 Self time:   0.000697

count  total (s)   self (s)
    3              0.000006     if a:0 > 1
                                    " Use the buffer number given as the optional second argument.
    3              0.000008         let l:buffer = a:2
    3              0.000007     elseif a:0 > 0 && a:1 == s:lint_timer
                                    " Use the buffer number for the buffer linting was queued for.
                                    let l:buffer = s:queued_buffer_number
                                else
                                    " Use the current buffer number.
                                    let l:buffer = bufnr('')
                                endif
                            
    3   0.000429   0.000022     if ale#ShouldDoNothing(l:buffer)
                                    return
                                endif
                            
                                " Use the filetype from the buffer
    3              0.000017     let l:filetype = getbufvar(l:buffer, '&filetype')
    3   0.001740   0.000063     let l:linters = ale#linter#Get(l:filetype)
    3              0.000010     let l:should_lint_file = 0
                            
                                " Check if we previously requested checking the file.
    3              0.000021     if has_key(s:should_lint_file_for_buffer, l:buffer)
    1              0.000003         unlet s:should_lint_file_for_buffer[l:buffer]
                                    " Lint files if they exist.
    1              0.000042         let l:should_lint_file = filereadable(expand('#' . l:buffer . ':p'))
    1              0.000001     endif
                            
                                " Apply ignore lists for linters only if needed.
    3   0.000168   0.000034     let l:ignore_config = ale#Var(l:buffer, 'linters_ignore')
    3              0.000029     let l:linters = !empty(l:ignore_config)   ? ale#engine#ignore#Exclude(l:filetype, l:linters, l:ignore_config)   : l:linters
                            
    3   0.066349   0.000346     call ale#engine#RunLinters(l:buffer, l:linters, l:should_lint_file)

FUNCTION  gitgutter#hunk#summary()
Called 179 times
Total time:   0.003535
 Self time:   0.001431

count  total (s)   self (s)
  179   0.003432   0.001328   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  ale#linter#GetAll()
Called 6 times
Total time:   0.000404
 Self time:   0.000404

count  total (s)   self (s)
    6              0.000018     let l:combined_linters = []
                            
   12              0.000033     for l:filetype in a:filetypes
                                    " Load linters from runtimepath if we haven't done that yet.
    6              0.000030         if !has_key(s:runtime_loaded_map, l:filetype)
                                        execute 'silent! runtime! ale_linters/' . l:filetype . '/*.vim'
                            
                                        let s:runtime_loaded_map[l:filetype] = 1
                                    endif
                            
    6              0.000110         call extend(l:combined_linters, get(s:linters, l:filetype, []))
    6              0.000025     endfor
                            
    6              0.000015     return l:combined_linters

FUNCTION  <SNR>142_SendKeys()
Called 64 times
Total time:   0.000664
 Self time:   0.000664

count  total (s)   self (s)
                              " By default keys are added to the end of the typeahead buffer. If there are
                              " already keys in the buffer, they will be processed first and may change the
                              " state that our keys combination was sent for (e.g. <C-X><C-U><C-P> in normal
                              " mode instead of insert mode or <C-e> outside of completion mode). We avoid
                              " that by inserting the keys at the start of the typeahead buffer with the 'i'
                              " option. Also, we don't want the keys to be remapped to something else so we
                              " add the 'n' option.
   64              0.000351   call feedkeys( a:keys, 'in' )

FUNCTION  <SNR>142_OnTextChangedNormalMode()
Called 1 time
Total time:   0.000249
 Self time:   0.000038

count  total (s)   self (s)
    1   0.000099   0.000024   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
    1   0.000145   0.000009   call s:OnFileReadyToParse()

FUNCTION  ale#engine#RemoveManagedFiles()
Called 3 times
Total time:   0.001185
 Self time:   0.001152

count  total (s)   self (s)
    3              0.000014     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
                                " We can't delete anything in a sandbox, so wait until we escape from
                                " it to delete temporary files and directories.
    3   0.000044   0.000011     if ale#util#InSandbox()
                                    return
                                endif
                            
                                " Delete files with a call akin to a plan `rm` command.
    3              0.000009     if has_key(l:info, 'temporary_file_list')
    3              0.000006         for l:filename in l:info.temporary_file_list
                                        call delete(l:filename)
                                    endfor
                            
    3              0.000006         let l:info.temporary_file_list = []
    3              0.000002     endif
                            
                                " Delete directories like `rm -rf`.
                                " Directories are handled differently from files, so paths that are
                                " intended to be single files can be set up for automatic deletion without
                                " accidentally deleting entire directories.
    3              0.000007     if has_key(l:info, 'temporary_directory_list')
    6              0.000011         for l:directory in l:info.temporary_directory_list
    3              0.000992             call delete(l:directory, 'rf')
    3              0.000032         endfor
                            
    3              0.000011         let l:info.temporary_directory_list = []
    3              0.000003     endif

FUNCTION  <SNR>142_Pyeval()
Called 258 times
Total time:   0.043562
 Self time:   0.043562

count  total (s)   self (s)
  258              0.000556   if s:using_python3
  258              0.042658     return py3eval( a:eval_string )
                              endif
                              return pyeval( a:eval_string )

FUNCTION  <SNR>19_is_cr_expansion()
Called 1 time
Total time:   0.000149
 Self time:   0.000081

count  total (s)   self (s)
    1              0.000011   let nchar = getline(line('.')-1)[-1:]
    1              0.000016   let schar = matchstr(getline(line('.')+1), '^\s*\zs\S')
    1              0.000010   let isEmpty = a:0 ? getline('.') =~ '^\s*$' : empty(getline('.'))
    1   0.000055   0.000019   if index(s:get('left_delims'), nchar) > -1 && index(s:get('left_delims'), nchar)    == index(s:get('right_delims'), schar) && isEmpty
                                return 1
                              elseif index(s:get('quotes_list'), nchar) > -1 && index(s:get('quotes_list'), nchar)    == index(s:get('quotes_list'), schar) && isEmpty
                                return 1
                              else
    1              0.000002     return 0
                              endif

FUNCTION  <SNR>107_get_hunks()
Called 179 times
Total time:   0.012218
 Self time:   0.004560

count  total (s)   self (s)
  179              0.000930   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
                                if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
                                  let b:source_func = 's:get_hunks_gitgutter'
                                elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                else
                                  let b:source_func = 's:get_hunks_empty'
                                endif
                              endif
  179   0.008805   0.001147   return {b:source_func}()

FUNCTION  ale#list#SetLists()
Called 4 times
Total time:   0.091957
 Self time:   0.000098

count  total (s)   self (s)
    4              0.000033     if get(g:, 'ale_set_lists_synchronously') == 1|| getbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Update lists immediately if running a test synchronously, or if the
                                    " buffer was saved.
                                    "
                                    " The lists need to be updated immediately when saving a buffer so
                                    " that we can reliably close window automatically, if so configured.
    2   0.091844   0.000014         call s:SetListsImpl(-1, a:buffer, a:loclist)
    2              0.000002     else
    2   0.000049   0.000020         call ale#util#StartPartialTimer(   0,   function('s:SetListsImpl'),   [a:buffer, a:loclist],)
    2              0.000002     endif

FUNCTION  ale#util#InSandbox()
Called 78 times
Total time:   0.001253
 Self time:   0.001253

count  total (s)   self (s)
   78              0.000118     try
   78              0.000273         function! s:SandboxCheck() abort
                                    endfunction
   78              0.000139     catch /^Vim\%((\a\+)\)\=:E48/
                                    " E48 is the sandbox error.
                                    return 1
                                endtry
                            
   78              0.000077     return 0

FUNCTION  airline#parts#crypt()
Called 179 times
Total time:   0.000950
 Self time:   0.000950

count  total (s)   self (s)
  179              0.000843   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  ale#path#Simplify()
Called 788 times
Total time:   0.006123
 Self time:   0.006123

count  total (s)   self (s)
  788              0.001514     if has('unix')
  788              0.004203         return substitute(simplify(a:path), '^//\+', '/', 'g') " no-custom-checks
                                endif
                            
                                let l:win_path = substitute(a:path, '/', '\\', 'g')
                            
                                return substitute(simplify(l:win_path), '^\\\+', '\', 'g') " no-custom-checks

FUNCTION  airline#extensions#keymap#status()
Called 179 times
Total time:   0.001970
 Self time:   0.001970

count  total (s)   self (s)
  179              0.000957   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
  179              0.000865     return printf('%s', (!empty(&keymap) ? (g:airline_symbols.keymap . ' '. &keymap) : ''))
                              else
                                return ''
                              endif

FUNCTION  ale#path#Upwards()
Called 20 times
Total time:   0.003912
 Self time:   0.003496

count  total (s)   self (s)
   20              0.000128     let l:pattern = has('win32') ? '\v/+|\\+' : '\v/+'
   20              0.000076     let l:sep = has('win32') ? '\' : '/'
   20   0.000977   0.000561     let l:parts = split(ale#path#Simplify(a:path), l:pattern)
   20              0.000037     let l:path_list = []
                            
  160              0.000257     while !empty(l:parts)
  140              0.000835         call add(l:path_list, join(l:parts, l:sep))
  140              0.000472         let l:parts = l:parts[:-2]
  140              0.000084     endwhile
                            
   20              0.000077     if has('win32') && a:path =~# '^[a-zA-z]:\'
                                    " Add \ to C: for C:\, etc.
                                    let l:path_list[-1] .= '\'
                                elseif a:path[0] is# '/'
                                    " If the path starts with /, even on Windows, add / and / to all paths.
   20              0.000597         call map(l:path_list, '''/'' . v:val')
   20              0.000038         call add(l:path_list, '/')
   20              0.000013     endif
                            
   20              0.000025     return l:path_list

FUNCTION  ale#util#GetLineCount()
Called 4 times
Total time:   0.001519
 Self time:   0.001519

count  total (s)   self (s)
    4              0.001509     return len(getbufline(a:buffer, 1, '$'))

FUNCTION  ale#engine#FixLocList()
Called 4 times
Total time:   0.056292
 Self time:   0.054673

count  total (s)   self (s)
    4              0.000008     let l:bufnr_map = {}
    4              0.000007     let l:new_loclist = []
                            
                                " Some errors have line numbers beyond the end of the file,
                                " so we need to adjust them so they set the error at the last line
                                " of the file instead.
    4   0.001544   0.000025     let l:last_line_number = ale#util#GetLineCount(a:buffer)
                            
  784              0.000666     for l:old_item in a:loclist
                                    " Copy the loclist item with some default values and corrections.
                                    "
                                    " line and column numbers will be converted to numbers.
                                    " The buffer will default to the buffer being checked.
                                    " The vcol setting will default to 0, a byte index.
                                    " The error type will default to 'E' for errors.
                                    " The error number will default to -1.
                                    "
                                    " The line number and text are the only required keys.
                                    "
                                    " The linter_name will be set on the errors so it can be used in
                                    " output, filtering, etc..
  780              0.007779         let l:item = {   'bufnr': a:buffer,   'text': l:old_item.text,   'lnum': str2nr(l:old_item.lnum),   'col': str2nr(get(l:old_item, 'col', 0)),   'vcol': 0,   'type': get(l:old_item, 'type', 'E'),   'nr': get(l:old_item, 'nr', -1),   'linter_name': a:linter_name,}
                            
  780              0.001258         if has_key(l:old_item, 'code')
  780              0.001124             let l:item.code = l:old_item.code
  780              0.000397         endif
                            
  780              0.002038         if has_key(l:old_item, 'filename')&& !ale#path#IsTempName(l:old_item.filename)
                                        " Use the filename given.
                                        " Temporary files are assumed to be for this buffer,
                                        " and the filename is not included then, because it looks bad
                                        " in the loclist window.
                                        let l:filename = l:old_item.filename
                                        let l:item.filename = l:filename
                            
                                        if has_key(l:old_item, 'bufnr')
                                            " If a buffer number is also given, include that too.
                                            " If Vim detects that he buffer number is valid, it will
                                            " be used instead of the filename.
                                            let l:item.bufnr = l:old_item.bufnr
                                        elseif has_key(l:bufnr_map, l:filename)
                                            " Get the buffer number from the map, which can be faster.
                                            let l:item.bufnr = l:bufnr_map[l:filename]
                                        else
                                            " Look up the buffer number.
                                            let l:item.bufnr = bufnr(l:filename)
                                            let l:bufnr_map[l:filename] = l:item.bufnr
                                        endif
                                    elseif has_key(l:old_item, 'bufnr')
                                        let l:item.bufnr = l:old_item.bufnr
                                    endif
                            
  780              0.001175         if has_key(l:old_item, 'detail')
                                        let l:item.detail = l:old_item.detail
                                    endif
                            
                                    " Pass on a end_col key if set, used for highlights.
  780              0.001294         if has_key(l:old_item, 'end_col')
                                        let l:item.end_col = str2nr(l:old_item.end_col)
                                    endif
                            
  780              0.001180         if has_key(l:old_item, 'end_lnum')
                                        let l:item.end_lnum = str2nr(l:old_item.end_lnum)
                                    endif
                            
  780              0.001212         if has_key(l:old_item, 'sub_type')
                                        let l:item.sub_type = l:old_item.sub_type
                                    endif
                            
  780              0.000687         if l:item.lnum < 1
                                        " When errors appear before line 1, put them at line 1.
                                        let l:item.lnum = 1
                                    elseif l:item.bufnr == a:buffer && l:item.lnum > l:last_line_number
                                        " When errors go beyond the end of the file, put them at the end.
                                        " This is only done for the current buffer.
                                        let l:item.lnum = l:last_line_number
                                    elseif get(l:old_item, 'vcol', 0)
                                        " Convert virtual column positions to byte positions.
                                        " The positions will be off if the buffer has changed recently.
                                        let l:line = getbufline(a:buffer, l:item.lnum)[0]
                            
                                        let l:item.col = ale#util#Col(l:line, l:item.col)
                            
                                        if has_key(l:item, 'end_col')
                                            let l:end_line = get(l:item, 'end_lnum', l:line) != l:line   ? getbufline(a:buffer, l:item.end_lnum)[0]   : l:line
                            
                                            let l:item.end_col = ale#util#Col(l:end_line, l:item.end_col)
                                        endif
                                    endif
                            
  780              0.001348         call add(l:new_loclist, l:item)
  780              0.000591     endfor
                            
    4   0.000138   0.000038     let l:type_map = get(ale#Var(a:buffer, 'type_map'), a:linter_name, {})
                            
    4              0.000009     if !empty(l:type_map)
                                    call s:RemapItemTypes(l:type_map, l:new_loclist)
                                endif
                            
    4              0.000006     return l:new_loclist

FUNCTION  <SNR>136_VimCloseCallback()
Called 4 times
Total time:   1.097600
 Self time:   0.001481

count  total (s)   self (s)
    4              0.000055     let l:job = ch_getjob(a:channel)
    4   0.000113   0.000057     let l:job_id = ale#job#ParseVim8ProcessID(string(l:job))
    4              0.000027     let l:info = get(s:job_map, l:job_id, {})
                            
    4              0.000012     if empty(l:info)
                                    return
                                endif
                            
                                " job_status() can trigger the exit handler.
                                " The channel can close before the job has exited.
    4   0.590641   0.000077     if job_status(l:job) is# 'dead'
    4              0.000013         try
    4              0.000018             if !empty(l:info) && has_key(l:info, 'exit_cb')
    4   0.506648   0.001149                 call ale#util#GetFunction(l:info.exit_cb)(l:job_id, get(l:info, 'exit_code', 1))
    4              0.000005             endif
    4              0.000003         finally
                                        " Automatically forget about the job after it's done.
    4              0.000013             if has_key(s:job_map, l:job_id)
    1              0.000003                 call remove(s:job_map, l:job_id)
    1              0.000001             endif
    4              0.000003         endtry
    4              0.000003     endif

FUNCTION  GitGutterGetHunkSummary()
Called 179 times
Total time:   0.004600
 Self time:   0.001065

count  total (s)   self (s)
  179   0.004503   0.000968   return gitgutter#hunk#summary(winbufnr(0))

FUNCTION  airline#parts#mode()
Called 179 times
Total time:   0.004311
 Self time:   0.001419

count  total (s)   self (s)
  179   0.004212   0.001320   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  ale#highlight#UpdateHighlights()
Called 4 times
Total time:   0.144325
 Self time:   0.106306

count  total (s)   self (s)
    4              0.000025     let l:item_list = get(b:, 'ale_enabled', 1) && g:ale_enabled   ? get(b:, 'ale_highlight_items', [])   : []
                            
    4   0.024109   0.000023     call ale#highlight#RemoveHighlights()
                            
 3121              0.002696     for l:item in l:item_list
 3117              0.003937         if l:item.type is# 'W'
 3116              0.006935             if get(l:item, 'sub_type', '') is# 'style'
                                            let l:group = 'ALEStyleWarning'
                                        else
 3116              0.003573                 let l:group = 'ALEWarning'
 3116              0.001638             endif
 3116              0.002486         elseif l:item.type is# 'I'
                                        let l:group = 'ALEInfo'
                                    elseif get(l:item, 'sub_type', '') is# 'style'
                                        let l:group = 'ALEStyleError'
                                    else
    1              0.000001             let l:group = 'ALEError'
    1              0.000001         endif
                            
 3117              0.003656         let l:line = l:item.lnum
 3117              0.003151         let l:col = l:item.col
 3117              0.006630         let l:end_line = get(l:item, 'end_lnum', l:line)
 3117              0.006264         let l:end_col = get(l:item, 'end_col', l:col)
                            
                                    " Set all of the positions, which are chunked into Lists which
                                    " are as large as will be accepted by matchaddpos.
 3117   0.053394   0.039461         call map(   ale#highlight#CreatePositions(l:line, l:col, l:end_line, l:end_col),   'matchaddpos(l:group, v:val)')
 3117              0.003292     endfor
                            
                                " If highlights are enabled and signs are not enabled, we should still
                                " offer line highlights by adding a separate set of highlights.
    4              0.000006     if !g:ale_set_signs
                                    let l:available_groups = {   'ALEWarningLine': hlexists('ALEWarningLine'),   'ALEInfoLine': hlexists('ALEInfoLine'),   'ALEErrorLine': hlexists('ALEErrorLine'),}
                            
                                    for l:item in l:item_list
                                        if l:item.type is# 'W'
                                            let l:group = 'ALEWarningLine'
                                        elseif l:item.type is# 'I'
                                            let l:group = 'ALEInfoLine'
                                        else
                                            let l:group = 'ALEErrorLine'
                                        endif
                            
                                        if l:available_groups[l:group]
                                            call matchaddpos(l:group, [l:item.lnum])
                                        endif
                                    endfor
                                endif

FUNCTION  ale#python#FindExecutable()
Called 8 times
Total time:   0.024064
 Self time:   0.000322

count  total (s)   self (s)
    8   0.000306   0.000069     if ale#Var(a:buffer, a:base_var_name . '_use_global')
                                    return ale#Var(a:buffer, a:base_var_name . '_executable')
                                endif
                            
    8   0.023388   0.000056     let l:virtualenv = ale#python#FindVirtualenv(a:buffer)
                            
    8              0.000017     if !empty(l:virtualenv)
                                    for l:path in a:path_list
                                        let l:ve_executable = ale#path#Simplify(   join([l:virtualenv, s:bin_dir, l:path], s:sep))
                            
                                        if executable(l:ve_executable)
                                            return l:ve_executable
                                        endif
                                    endfor
                                endif
                            
    8   0.000227   0.000054     return ale#Var(a:buffer, a:base_var_name . '_executable')

FUNCTION  ale#highlight#SetHighlights()
Called 4 times
Total time:   0.148415
 Self time:   0.004090

count  total (s)   self (s)
    4              0.002684     let l:new_list = getbufvar(a:buffer, 'ale_enabled', 1) && g:ale_enabled   ? filter(copy(a:loclist), 'v:val.bufnr == a:buffer && v:val.col > 0')   : []
                            
                                " Set the list in the buffer variable.
    4              0.001358     call setbufvar(str2nr(a:buffer), 'ale_highlight_items', l:new_list)
                            
                                " Update highlights for the current buffer, which may or may not
                                " be the buffer we just set highlights for.
    4   0.144360   0.000035     call ale#highlight#UpdateHighlights()

FUNCTION  <SNR>68_CurrentTimeStr()
Called 1 time
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
    1              0.000008         if s:has_reltime
    1              0.000047             return split(reltimestr(reltime()))[0]
                                    endif
                                    return s:n2s(localtime())

FUNCTION  ale#engine#SetResults()
Called 4 times
Total time:   0.798012
 Self time:   0.006750

count  total (s)   self (s)
    4   0.000077   0.000033     let l:linting_is_done = !ale#engine#IsCheckingBuffer(a:buffer)
                            
                                " Set signs first. This could potentially fix some line numbers.
                                " The List could be sorted again here by SetSigns.
    4              0.000006     if g:ale_set_signs
    4   0.513537   0.005806         call ale#sign#SetSigns(a:buffer, a:loclist)
    4              0.000005     endif
                            
    4              0.000011     if g:ale_set_quickfix || g:ale_set_loclist
    4   0.092002   0.000045         call ale#list#SetLists(a:buffer, a:loclist)
    4              0.000003     endif
                            
    4              0.000011     if exists('*ale#statusline#Update')
                                    " Don't load/run if not already loaded.
    4   0.042223   0.000340         call ale#statusline#Update(a:buffer, a:loclist)
    4              0.000003     endif
                            
    4              0.000007     if g:ale_set_highlights
    4   0.148449   0.000034         call ale#highlight#SetHighlights(a:buffer, a:loclist)
    4              0.000004     endif
                            
    4              0.000006     if l:linting_is_done
    3              0.000004         if g:ale_echo_cursor
                                        " Try and echo the warning now.
                                        " This will only do something meaningful if we're in normal mode.
    3   0.000046   0.000020             call ale#cursor#EchoCursorWarning()
    3              0.000002         endif
                            
                                    " Reset the save event marker, used for opening windows, etc.
    3              0.000016         call setbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Set a marker showing how many times a buffer has been checked.
    3              0.000014         call setbufvar(   a:buffer,   'ale_linted',   getbufvar(a:buffer, 'ale_linted', 0) + 1)
                            
                                    " Automatically remove all managed temporary files and directories
                                    " now that all jobs have completed.
    3   0.001204   0.000019         call ale#engine#RemoveManagedFiles(a:buffer)
                            
                                    " Call user autocommands. This allows users to hook into ALE's lint cycle.
    3   0.000244   0.000236         silent doautocmd <nomodeline> User ALELintPost
                                    " remove in 2.0
                                    " Old DEPRECATED name; call it for backwards compatibility.
    3   0.000078   0.000065         silent doautocmd <nomodeline> User ALELint
    3              0.000004     endif

FUNCTION  ale#sign#GetSignName()
Called 3117 times
Total time:   0.107227
 Self time:   0.074552

count  total (s)   self (s)
 3117              0.005076     let l:priority = g:ale#util#style_warning_priority
                            
                                " Determine the highest priority item for the line.
 6234              0.006607     for l:item in a:sublist
 3117   0.044107   0.011432         let l:item_priority = ale#util#GetItemPriority(l:item)
                            
 3117              0.004101         if l:item_priority > l:priority
 3117              0.003959             let l:priority = l:item_priority
 3117              0.001713         endif
 3117              0.001592     endfor
                            
 3117              0.003978     if l:priority is# g:ale#util#error_priority
    1              0.000000         return 'ALEErrorSign'
                                endif
                            
 3116              0.003720     if l:priority is# g:ale#util#warning_priority
 3116              0.002911         return 'ALEWarningSign'
                                endif
                            
                                if l:priority is# g:ale#util#style_error_priority
                                    return 'ALEStyleErrorSign'
                                endif
                            
                                if l:priority is# g:ale#util#style_warning_priority
                                    return 'ALEStyleWarningSign'
                                endif
                            
                                if l:priority is# g:ale#util#info_priority
                                    return 'ALEInfoSign'
                                endif
                            
                                " Use the error sign for invalid severities.
                                return 'ALEErrorSign'

FUNCTION  ale#util#GetMatches()
Called 4 times
Total time:   0.054712
 Self time:   0.054712

count  total (s)   self (s)
    4              0.000005     let l:matches = []
    4              0.000018     let l:lines = type(a:lines) == type([]) ? a:lines : [a:lines]
    4              0.000020     let l:patterns = type(a:patterns) == type([]) ? a:patterns : [a:patterns]
                            
 2345              0.002484     for l:line in l:lines
 3902              0.004101         for l:pattern in l:patterns
 2341              0.021632             let l:match = matchlist(l:line, l:pattern)
                            
 2341              0.003293             if !empty(l:match)
  780              0.001365                 call add(l:matches, l:match)
  780              0.000483                 break
                                        endif
 1561              0.000867         endfor
 2341              0.005272     endfor
                            
    4              0.000005     return l:matches

FUNCTION  <SNR>131_InvokeChain()
Called 4 times
Total time:   0.041584
 Self time:   0.000563

count  total (s)   self (s)
    4   0.014221   0.000033     let l:options = ale#engine#ProcessChain(a:buffer, a:linter, a:chain_index, a:input)
                            
    4   0.027345   0.000512     return s:RunJob(l:options)

FUNCTION  <SNR>68_AppendHeartbeat()
Called 1 time
Total time:   0.002365
 Self time:   0.000601

count  total (s)   self (s)
    1              0.000171         let file = a:file
    1              0.000015         if file == ''
                                        let file = a:last.file
                                    endif
    1              0.000002         if file != ''
    1              0.000016             let heartbeat = {}
    1              0.000006             let heartbeat.entity = file
    1   0.000147   0.000088             let heartbeat.time = s:CurrentTimeStr()
    1              0.000008             let heartbeat.is_write = a:is_write
    1              0.000013             if !empty(&syntax)
    1              0.000005                 let heartbeat.language = &syntax
    1              0.000001             else
                                            if !empty(&filetype)
                                                let heartbeat.language = &filetype
                                            endif
                                        endif
    1              0.000176             let s:heartbeats_buffer = s:heartbeats_buffer + [heartbeat]
    1   0.001743   0.000038             call s:SetLastHeartbeat(a:now, a:now, file)
                            
    1              0.000013             if !s:buffering_heartbeats_enabled
                                            call s:SendHeartbeats()
                                        endif
    1              0.000000         endif

FUNCTION  <SNR>131_GatherOutput()
Called 2341 times
Total time:   0.013430
 Self time:   0.013430

count  total (s)   self (s)
 2341              0.004737     if has_key(s:job_info_map, a:job_id)
 2341              0.006501         call add(s:job_info_map[a:job_id].output, a:line)
 2341              0.001163     endif

FUNCTION  ale#cursor#EchoCursorWarning()
Called 65 times
Total time:   0.035316
 Self time:   0.003602

count  total (s)   self (s)
   65              0.000446     if !g:ale_echo_cursor
                                    return
                                endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
   65              0.000326     if mode() isnot# 'n'
    4              0.000004         return
                                endif
                            
   61   0.008834   0.000531     if ale#ShouldDoNothing(bufnr(''))
                                    return
                                endif
                            
   61              0.000179     let l:buffer = bufnr('')
   61   0.023893   0.000482     let [l:info, l:loc] = s:FindItemAtCursor()
                            
   61              0.000120     if !empty(l:loc)
                                    let l:format = ale#Var(l:buffer, 'echo_msg_format')
                                    let l:msg = ale#GetLocItemMessage(l:loc, l:format)
                                    call ale#cursor#TruncatedEcho(l:msg)
                                    let l:info.echoed = 1
                                elseif get(l:info, 'echoed')
                                    " We'll only clear the echoed message when moving off errors once,
                                    " so we don't continually clear the echo line.
                                    execute 'echo'
                                    let l:info.echoed = 0
                                endif

FUNCTION  ale#engine#HandleLoclist()
Called 4 times
Total time:   1.022906
 Self time:   0.018473

count  total (s)   self (s)
    4              0.000019     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
    4              0.000007     if empty(l:info)
                                    return
                                endif
                            
                                " Remove this linter from the list of active linters.
                                " This may have already been done when the job exits.
    4              0.000017     call filter(l:info.active_linter_list, 'v:val isnot# a:linter_name')
                            
                                " Make some adjustments to the loclists to fix common problems, and also
                                " to set default values for loclist items.
    4   0.056337   0.000045     let l:linter_loclist = ale#engine#FixLocList(a:buffer, a:linter_name, a:loclist)
                            
                                " Remove previous items for this linter.
    4              0.002951     call filter(l:info.loclist, 'v:val.linter_name isnot# a:linter_name')
                            
                                " We don't need to add items or sort the list when this list is empty.
    4              0.000013     if !empty(l:linter_loclist)
                                    " Add the new items.
    1              0.000139         call extend(l:info.loclist, l:linter_loclist)
                            
                                    " Sort the loclist again.
                                    " We need a sorted list so we can run a binary search against it
                                    " for efficient lookup of the messages in the cursor handler.
    1   0.164864   0.015149         call sort(l:info.loclist, 'ale#util#LocItemCompare')
    1              0.000001     endif
                            
    4   0.000439   0.000025     if ale#ShouldDoNothing(a:buffer)
                                    return
                                endif
                            
    4   0.798050   0.000038     call ale#engine#SetResults(a:buffer, l:info.loclist)

FUNCTION  <SNR>142_InsideCommentOrStringAndShouldStop()
Called 47 times
Total time:   0.007595
 Self time:   0.000647

count  total (s)   self (s)
   47   0.007179   0.000231   let retval = s:InsideCommentOrString()
   47              0.000080   let inside_comment = retval == 1
   47              0.000053   let inside_string = retval == 2
                            
   47              0.000110   if inside_comment && g:ycm_complete_in_comments || inside_string && g:ycm_complete_in_strings
                                return 0
                              endif
                            
   47              0.000039   return retval

FUNCTION  airline#statusline()
Called 179 times
Total time:   0.003995
 Self time:   0.003995

count  total (s)   self (s)
  179              0.002073   if has_key(s:contexts, a:winnr)
  179              0.001501     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                            
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  ale#engine#GetLoclist()
Called 179 times
Total time:   0.001305
 Self time:   0.001305

count  total (s)   self (s)
  179              0.000463     if !has_key(g:ale_buffer_info, a:buffer)
                                    return []
                                endif
                            
  179              0.000341     return g:ale_buffer_info[a:buffer].loclist

FUNCTION  youcompleteme#CompleteFunc()
Called 88 times
Total time:   0.000580
 Self time:   0.000580

count  total (s)   self (s)
   88              0.000189   if a:findstart
   44              0.000150     return s:completion.start_column - 1
                              endif
   44              0.000066   return s:completion.candidates

FUNCTION  <SNR>142_OnInsertChar()
Called 48 times
Total time:   0.007974
 Self time:   0.001649

count  total (s)   self (s)
   48   0.006130   0.000728   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
   48              0.000322   call timer_stop( s:pollers.completion.id )
   48   0.001273   0.000350   call s:CloseCompletionMenu()

FUNCTION  <SNR>131_CreateTemporaryFileForJob()
Called 4 times
Total time:   0.019293
 Self time:   0.000880

count  total (s)   self (s)
    4              0.000008     if empty(a:temporary_file)
                                    " There is no file, so we didn't create anything.
    1              0.000001         return 0
                                endif
                            
    3              0.000010     let l:temporary_directory = fnamemodify(a:temporary_file, ':h')
                                " Create the temporary directory for the file, unreadable by 'other'
                                " users.
    3              0.000247     call mkdir(l:temporary_directory, '', 0750)
                                " Automatically delete the directory later.
    3   0.000088   0.000023     call ale#engine#ManageDirectory(a:buffer, l:temporary_directory)
                                " Write the buffer out to a file.
    3              0.000515     let l:lines = getbufline(a:buffer, 1, '$')
    3   0.018382   0.000034     call ale#util#Writefile(a:buffer, l:lines, a:temporary_file)
                            
    3              0.000016     return 1

FUNCTION  <SNR>97_is_python_string()
Called 1 time
Total time:   0.001032
 Self time:   0.001032

count  total (s)   self (s)
    1              0.000007     let line = getline(a:lnum)
    1              0.000006     let linelen = len(line)
    1              0.000003     if linelen < 1
                                  let linelen = 1
                                endif
    1              0.000014     let cols = a:0 ? type(a:1) != type([]) ? [a:1] : a:1 : range(1, linelen)
    1              0.000005     for cnum in cols
    1              0.000984         if match(map(synstack(a:lnum, cnum), "synIDattr(v:val, 'name')"), 'python\S*String') == -1
    1              0.000004             return 0
                                    end
                                endfor
                                return 1

FUNCTION  airline#highlighter#get_highlight()
Called 566 times
Total time:   0.077426
 Self time:   0.034452

count  total (s)   self (s)
  566              0.002656   if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                return s:hl_groups[a:group]
                              else
  566   0.023113   0.004113     let fg = s:get_syn(a:group, 'fg')
  566   0.020990   0.003267     let bg = s:get_syn(a:group, 'bg')
  566              0.006926     let reverse = g:airline_gui_mode ==# 'gui' ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
  566              0.002924     let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
  566              0.000943     let opts = a:000
  566              0.000642     if bold
  248              0.000414       let opts = ['bold']
  248              0.000182     endif
  566   0.011103   0.004852     let res = reverse ? s:get_array(bg, fg, opts) : s:get_array(fg, bg, opts)
  566              0.000466   endif
  566              0.003031   let s:hl_groups[a:group] = res
  566              0.000640   return res

FUNCTION  ale#history#Add()
Called 4 times
Total time:   0.000244
 Self time:   0.000244

count  total (s)   self (s)
    4              0.000009     if g:ale_max_buffer_history_size <= 0
                                    " Don't save anything if the history isn't a positive number.
                                    call setbufvar(a:buffer, 'ale_history', [])
                            
                                    return
                                endif
                            
    4              0.000040     let l:history = getbufvar(a:buffer, 'ale_history', [])
                            
                                " Remove the first item if we hit the max history size.
    4              0.000013     if len(l:history) >= g:ale_max_buffer_history_size
                                    let l:history = l:history[1:]
                                endif
                            
    4              0.000065     call add(l:history, {   'status': a:status,   'job_id': a:job_id,   'command': a:command,})
                            
    4              0.000042     call setbufvar(a:buffer, 'ale_history', l:history)

FUNCTION  <SNR>115_get_array()
Called 566 times
Total time:   0.006251
 Self time:   0.006251

count  total (s)   self (s)
  566              0.002876   let opts=empty(a:opts) ? '' : join(a:opts, ',')
  566              0.003014   return g:airline_gui_mode ==# 'gui' ? [ a:fg, a:bg, '', '', opts ] : [ '', '', a:fg, a:bg, opts ]

FUNCTION  <SNR>110_check_mixed_indent()
Called 1 time
Total time:   0.033310
 Self time:   0.033310

count  total (s)   self (s)
    1              0.000006   let indent_algo = get(g:, 'airline#extensions#whitespace#mixed_indent_algo', 0)
    1              0.000002   if indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less than tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
                              elseif indent_algo == 2
                                return search('\v(^\t* +\t\s*\S)', 'nw')
                              else
    1              0.033286     return search('\v(^\t+ +)|(^ +\t+)', 'nw')
                              endif

FUNCTION  <SNR>121_ApplyPartialTimer()
Called 2 times
Total time:   0.119543
 Self time:   0.000081

count  total (s)   self (s)
    2              0.000028     if has_key(s:partial_timers, a:timer_id)
    2              0.000020         let [l:Callback, l:args] = remove(s:partial_timers, a:timer_id)
    2   0.119489   0.000027         call call(l:Callback, [a:timer_id] + l:args)
    2              0.000000     endif

FUNCTION  <SNR>68_SanitizeArg()
Called 13 times
Total time:   0.000117
 Self time:   0.000117

count  total (s)   self (s)
   13              0.000039         let sanitized = shellescape(a:arg)
   13              0.000051         let sanitized = substitute(sanitized, '!', '\\!', 'g')
   13              0.000015         return sanitized

FUNCTION  ale_linters#python#mypy#GetCommand()
Called 3 times
Total time:   0.010788
 Self time:   0.000138

count  total (s)   self (s)
    3   0.003046   0.000019     let l:dir = s:GetDir(a:buffer)
    3   0.007442   0.000022     let l:executable = ale_linters#python#mypy#GetExecutable(a:buffer)
                            
    3              0.000015     let l:exec_args = l:executable =~? 'pipenv$'   ? ' run mypy'   : ''
                            
                                " We have to always switch to an explicit directory for a command so
                                " we can know with certainty the base path for the 'filename' keys below.
    3   0.000279   0.000076     return ale#path#CdString(l:dir)   . ale#Escape(l:executable) . l:exec_args   . ' --show-column-numbers '   . ale#Var(a:buffer, 'python_mypy_options')   . ' --shadow-file %s %t %s'

FUNCTION  airline#highlighter#highlight_modified_inactive()
Called 5 times
Total time:   0.002252
 Self time:   0.000253

count  total (s)   self (s)
    5              0.000028   if getbufvar(a:bufnr, '&modified')
    4              0.000071     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
    4              0.000003   else
    1              0.000019     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    1              0.000001   endif
                            
    5              0.000008   if !empty(colors)
    5   0.002072   0.000073     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
    5              0.000004   endif

FUNCTION  ale#job#PrepareCommand()
Called 4 times
Total time:   0.000315
 Self time:   0.000208

count  total (s)   self (s)
    4   0.000136   0.000029     let l:wrapper = ale#Var(a:buffer, 'command_wrapper')
                            
    4              0.000024     let l:command = !empty(l:wrapper) ? s:PrepareWrappedCommand(l:wrapper, a:command) : a:command
                            
                                " The command will be executed in a subshell. This fixes a number of
                                " issues, including reading the PATH variables correctly, %PATHEXT%
                                " expansion on Windows, etc.
                                "
                                " NeoVim handles this issue automatically if the command is a String,
                                " but we'll do this explicitly, so we use the same exact command for both
                                " versions.
    4              0.000017     if has('win32')
                                    return 'cmd /s/c "' . l:command . '"'
                                endif
                            
    4              0.000035     if &shell =~? 'fish$\|pwsh$'
                                    return ['/bin/sh', '-c', l:command]
                                endif
                            
    4              0.000053     return split(&shell) + split(&shellcmdflag) + [l:command]

FUNCTION  <SNR>68_GetCurrentFile()
Called 108 times
Total time:   0.007550
 Self time:   0.007550

count  total (s)   self (s)
  108              0.007471         return expand("%:p")

FUNCTION  ale#engine#ProcessChain()
Called 4 times
Total time:   0.014188
 Self time:   0.000361

count  total (s)   self (s)
    4              0.000018     let l:output_stream = get(a:linter, 'output_stream', 'stdout')
    4              0.000009     let l:read_buffer = a:linter.read_buffer
    4              0.000009     let l:chain_index = a:chain_index
    4              0.000005     let l:input = a:input
                            
    4              0.000010     if has_key(a:linter, 'command_chain')
                                    while l:chain_index < len(a:linter.command_chain)
                                        " Run a chain of commands, one asynchronous command after the other,
                                        " so that many programs can be run in a sequence.
                                        let l:chain_item = a:linter.command_chain[l:chain_index]
                            
                                        if l:chain_index == 0
                                            " The first callback in the chain takes only a buffer number.
                                            let l:command = ale#util#GetFunction(l:chain_item.callback)(   a:buffer)
                                        else
                                            " The second callback in the chain takes some input too.
                                            let l:command = ale#util#GetFunction(l:chain_item.callback)(   a:buffer,   l:input)
                                        endif
                            
                                        if !empty(l:command)
                                            " We hit a command to run, so we'll execute that
                            
                                            " The chain item can override the output_stream option.
                                            if has_key(l:chain_item, 'output_stream')
                                                let l:output_stream = l:chain_item.output_stream
                                            endif
                            
                                            " The chain item can override the read_buffer option.
                                            if has_key(l:chain_item, 'read_buffer')
                                                let l:read_buffer = l:chain_item.read_buffer
                                            elseif l:chain_index != len(a:linter.command_chain) - 1
                                                " Don't read the buffer for commands besides the last one
                                                " in the chain by default.
                                                let l:read_buffer = 0
                                            endif
                            
                                            break
                                        endif
                            
                                        " Command chain items can return an empty string to indicate that
                                        " a command should be skipped, so we should try the next item
                                        " with no input.
                                        let l:input = []
                                        let l:chain_index += 1
                                    endwhile
                                else
    4   0.013856   0.000029         let l:command = ale#linter#GetCommand(a:buffer, a:linter)
    4              0.000003     endif
                            
    4              0.000030     return {   'command': l:command,   'buffer': a:buffer,   'linter': a:linter,   'output_stream': l:output_stream,   'next_chain_index': l:chain_index + 1,   'read_buffer': l:read_buffer,}

FUNCTION  airline#extensions#hunks#get_hunks()
Called 179 times
Total time:   0.025835
 Self time:   0.013617

count  total (s)   self (s)
  179              0.000489   if !get(w:, 'airline_active', 0)
                                return ''
                              endif
                              " Cache values, so that it isn't called too often
  179              0.002457   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && winwidth(0) == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty' && get(b:, 'source_func', '') isnot# 's:get_hunks_changes'
                                return b:airline_hunks
                              endif
  179   0.013017   0.000799   let hunks = s:get_hunks()
  179              0.000203   let string = ''
  179              0.000299   if !empty(hunks)
  716              0.000945     for i in [0, 1, 2]
  537              0.001379       if (s:non_zero_only == 0 && winwidth(0) > 100) || hunks[i] > 0
  537              0.002733         let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
  537              0.000317       endif
  537              0.000333     endfor
  179              0.000116   endif
  179              0.000335   let b:airline_hunks = string
  179              0.000318   let b:airline_changenr = b:changedtick
  179              0.000370   let s:airline_winwidth = winwidth(0)
  179              0.000179   return string

FUNCTION  delimitMate#BS()
Called 1 time
Total time:   0.001460
 Self time:   0.000183

count  total (s)   self (s)
    1   0.000640   0.000048   if s:is_forbidden("")
                                let extra = ''
                              elseif &bs !~ 'start\|2'
                                let extra = ''
                              elseif delimitMate#WithinEmptyPair()
                                let extra = "\<Del>"
                              elseif s:is_space_expansion()
                                let extra = "\<Del>"
                              elseif s:is_cr_expansion()
                                let extra = repeat("\<Del>", len(matchstr(getline(line('.') + 1), '^\s*\S')))
                              else
    1              0.000003     let extra = ''
    1              0.000002   endif
    1              0.000007   return "\<BS>" . extra

FUNCTION  ale#command#FormatCommand()
Called 4 times
Total time:   0.000659
 Self time:   0.000427

count  total (s)   self (s)
    4              0.000008     let l:temporary_file = ''
    4              0.000006     let l:command = a:command
                            
                                " First replace all uses of %%, used for literal percent characters,
                                " with an ugly string.
    4              0.000024     let l:command = substitute(l:command, '%%', '<<PERCENTS>>', 'g')
                            
                                " Replace all %s occurrences in the string with the name of the current
                                " file.
    4              0.000012     if l:command =~# '%s'
    4              0.000119         let l:filename = fnamemodify(bufname(a:buffer), ':p')
    4   0.000148   0.000058         let l:command = substitute(l:command, '%s', '\=ale#Escape(l:filename)', 'g')
    4              0.000001     endif
                            
    4              0.000010     if l:command =~# '%t'
                                    " Create a temporary filename, <temp_dir>/<original_basename>
                                    " The file itself will not be created by this function.
    3   0.000116   0.000018         let l:temporary_file = s:TemporaryFilename(a:buffer)
    3   0.000091   0.000047         let l:command = substitute(l:command, '%t', '\=ale#Escape(l:temporary_file)', 'g')
    3              0.000002     endif
                            
                                " Finish formatting so %% becomes %.
    4              0.000023     let l:command = substitute(l:command, '<<PERCENTS>>', '%', 'g')
                            
    4              0.000030     if a:pipe_file_if_needed && empty(l:temporary_file)
                                    " If we are to send the Vim buffer to a command, we'll do it
                                    " in the shell. We'll write out the file to a temporary file,
                                    " and then read it back in, in the shell.
                                    let l:temporary_file = s:TemporaryFilename(a:buffer)
                                    let l:command = l:command . ' < ' . ale#Escape(l:temporary_file)
                                endif
                            
    4              0.000010     return [l:temporary_file, l:command]

FUNCTION  gitgutter#utility#getbufvar()
Called 179 times
Total time:   0.002104
 Self time:   0.002104

count  total (s)   self (s)
  179              0.001117   let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
  179              0.000485   if has_key(dict, a:varname)
  179              0.000281     return dict[a:varname]
                              else
                                if a:0
                                  return a:1
                                endif
                              endif

FUNCTION  <SNR>68_GetPythonBinary()
Called 1 time
Total time:   0.000248
 Self time:   0.000223

count  total (s)   self (s)
    1              0.000003         let python_bin = g:wakatime_PythonBinary
    1              0.000031         if !filereadable(python_bin)
    1              0.000003             let paths = ['python3']
    1   0.000022   0.000008             if s:IsWindows()
                                            let pyver = 39
                                            while pyver >= 26
                                                let paths = paths + [printf('/Python%d/pythonw', pyver), printf('/python%d/pythonw', pyver), printf('/Python%d/python', pyver), printf('/python%d/python', pyver)]
                                                let pyver = pyver - 1
                                            endwhile
                                        else
    1              0.000012                 let paths = paths + ['/usr/bin/python3', '/usr/local/bin/python3', '/usr/bin/python3.6', '/usr/local/bin/python3.6', '/usr/bin/python', '/usr/local/bin/python', '/usr/bin/python2', '/usr/local/bin/python2']
    1              0.000000             endif
    1              0.000006             let paths = paths + ['python']
    1              0.000001             let index = 0
    1              0.000003             let limit = len(paths)
    4              0.000005             while index < limit
    3              0.000091                 if filereadable(paths[index])
    1              0.000004                     let python_bin = paths[index]
    1              0.000002                     let index = limit
    1              0.000001                 endif
    3              0.000005                 let index = index + 1
    3              0.000003             endwhile
    1              0.000001         endif
    1   0.000018   0.000007         if s:IsWindows() && filereadable(printf('%sw', python_bin))
                                        let python_bin = printf('%sw', python_bin)
                                    endif
    1              0.000001         return python_bin

FUNCTION  ale#sign#GetSignCommands()
Called 4 times
Total time:   0.078110
 Self time:   0.078110

count  total (s)   self (s)
    4              0.000009     let l:command_list = []
    4              0.000008     let l:is_dummy_sign_set = a:was_sign_set
                            
                                " Set the dummy sign if we need to.
                                " The dummy sign is needed to keep the sign column open while we add
                                " and remove signs.
    4              0.000013     if !l:is_dummy_sign_set && (!empty(a:sign_map) || g:ale_sign_column_always)
                                    call add(l:command_list, 'sign place '   .  g:ale_sign_offset   . ' line=1 name=ALEDummySign buffer='   . a:buffer)
                                    let l:is_dummy_sign_set = 1
                                endif
                            
                                " Place new items first.
 3121              0.005942     for [l:line_str, l:info] in items(a:sign_map)
 3117              0.002444         if l:info.new_id
                                        " Save the sign IDs we are setting back on our loclist objects.
                                        " These IDs will be used to preserve items which are set many times.
 6234              0.005720             for l:item in l:info.items
 3117              0.004011                 let l:item.sign_id = l:info.new_id
 3117              0.002561             endfor
                            
 3117              0.004891             if index(l:info.current_id_list, l:info.new_id) < 0
    1              0.000008                 call add(l:command_list, 'sign place '   . (l:info.new_id)   . ' line=' . l:line_str   . ' name=' . (l:info.new_name)   . ' buffer=' . a:buffer)
    1              0.000001             endif
 3117              0.001405         endif
 3117              0.001407     endfor
                            
                                " Remove signs without new IDs.
 3121              0.002805     for l:info in values(a:sign_map)
 6233              0.005812         for l:current_id in l:info.current_id_list
 3116              0.003357             if l:current_id isnot l:info.new_id
                                            call add(l:command_list, 'sign unplace '   . l:current_id   . ' buffer=' . a:buffer)
                                        endif
 3116              0.002443         endfor
 3117              0.001382     endfor
                            
                                " Remove the dummy sign to close the sign column if we need to.
    4              0.000009     if l:is_dummy_sign_set && !g:ale_sign_column_always
                                    call add(l:command_list, 'sign unplace '   . g:ale_sign_offset   . ' buffer=' . a:buffer)
                                endif
                            
    4              0.000005     return l:command_list

FUNCTION  ale_linters#python#pylint#GetCommand()
Called 1 time
Total time:   0.002957
 Self time:   0.000111

count  total (s)   self (s)
    1   0.000191   0.000087     let l:cd_string = ale#Var(a:buffer, 'python_pylint_change_directory')   ? ale#path#BufferCdString(a:buffer)   : ''
                            
    1   0.002716   0.000006     let l:executable = ale_linters#python#pylint#GetExecutable(a:buffer)
                            
    1              0.000005     let l:exec_args = l:executable =~? 'pipenv$'   ? ' run pylint'   : ''
                            
    1   0.000043   0.000011     return l:cd_string   . ale#Escape(l:executable) . l:exec_args   . ' ' . ale#Var(a:buffer, 'python_pylint_options')   . ' --output-format text --msg-template="{path}:{line}:{column}: {msg_id} ({symbol}) {msg}" --reports n'   . ' %s'

FUNCTION  airline#util#prepend()
Called 179 times
Total time:   0.001274
 Self time:   0.001274

count  total (s)   self (s)
  179              0.000415   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
  179              0.000511   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  <SNR>97_indent_like_opening_paren()
Called 1 time
Total time:   0.077146
 Self time:   0.000029

count  total (s)   self (s)
    1   0.077143   0.000026     let [paren_lnum, paren_col] = s:find_opening_paren(a:lnum)
    1              0.000001     if paren_lnum <= 0
    1              0.000001         return -2
                                endif
                                let text = getline(paren_lnum)
                                let base = indent(paren_lnum)
                            
                                let nothing_after_opening_paren = s:match_expr_on_line( s:skip_after_opening_paren, paren_lnum, paren_col+1)
                                let starts_with_closing_paren = getline(a:lnum) =~# '^\s*[])}]'
                            
                                if nothing_after_opening_paren
                                    if starts_with_closing_paren
                                        let res = base
                                    else
                                        let res = base + s:sw()
                                    endif
                                else
                                    " Indent to match position of opening paren.
                                    let res = paren_col
                                endif
                            
                                " If this line is the continuation of a control statement
                                " indent further to distinguish the continuation line
                                " from the next logical line.
                                if text =~# b:control_statement && res == base + s:sw()
                                    return base + s:sw() * 2
                                else
                                    return res
                                endif

FUNCTION  <SNR>97_indent_like_previous_line()
Called 1 time
Total time:   0.070354
 Self time:   0.000854

count  total (s)   self (s)
    1              0.000003     let lnum = prevnonblank(a:lnum - 1)
                            
                                " No previous line, keep current indent.
    1              0.000001     if lnum < 1
                                  return -1
                                endif
                            
    1              0.000002     let text = getline(lnum)
    1   0.068809   0.000008     let start = s:find_start_of_multiline_statement(lnum)
    1              0.000004     let base = indent(start)
    1              0.000002     let current = indent(a:lnum)
                            
                                " Jump to last character in previous line.
    1              0.000004     call cursor(lnum, len(text))
    1   0.000746   0.000395     let ignore_last_char = eval(s:skip_special_chars)
                            
                                " Search for final colon that is not inside something to be ignored.
    1              0.000001     while 1
    1              0.000005         let curpos = getpos('.')[2]
    1              0.000003         if curpos == 1 | break | endif
    1   0.000715   0.000367         if eval(s:skip_special_chars) || text[curpos-1] =~# '\s'
                                        normal! h
                                        continue
                                    elseif text[curpos-1] ==# ':'
                                        return base + s:sw()
                                    endif
    1              0.000001         break
                                endwhile
                            
    1              0.000003     if text =~# '\\$' && !ignore_last_char
                                    " If this line is the continuation of a control statement
                                    " indent further to distinguish the continuation line
                                    " from the next logical line.
                                    if getline(start) =~# b:control_statement
                                        return base + s:sw() * 2
                                    endif
                            
                                    " Nest (other) explicit continuations only one level deeper.
                                    return base + s:sw()
                                endif
                            
    1              0.000005     let empty = getline(a:lnum) =~# '^\s*$'
                            
                                " Current and prev line are empty, next is not -> indent like next.
    1              0.000005     if empty && a:lnum > 1 && (getline(a:lnum - 1) =~# '^\s*$') && !(getline(a:lnum + 1) =~# '^\s*$')
                                  return indent(a:lnum + 1)
                                endif
                            
                                " If the previous statement was a stop-execution statement or a pass
    1              0.000008     if getline(start) =~# s:stop_statement
                                    " Remove one level of indentation if the user hasn't already dedented
                                    if empty || current > base - s:sw()
                                        return base - s:sw()
                                    endif
                                    " Otherwise, trust the user
                                    return -1
                                endif
                            
    1              0.000002     if !empty && s:is_dedented_already(current, base)
                                    return -1
                                endif
                            
                                " In all other cases, line up with the start of the previous statement.
    1              0.000001     return base

FUNCTION  ale#sign#SetSigns()
Called 4 times
Total time:   0.507731
 Self time:   0.003617

count  total (s)   self (s)
    4              0.000019     if !bufexists(str2nr(a:buffer))
                                    " Stop immediately when attempting to set signs for a buffer which
                                    " does not exist.
                                    return
                                endif
                            
                                " Find the current markers
    4   0.102175   0.000449     let [l:is_dummy_sign_set, l:current_sign_list] =   ale#sign#FindCurrentSigns(a:buffer)
                            
                                " Update the line numbers for items from before which may have moved.
    4   0.044437   0.000310     call s:UpdateLineNumbers(a:buffer, l:current_sign_list, a:loclist)
                            
                                " Group items after updating the line numbers.
    4   0.032612   0.000059     let l:grouped_items = s:GroupLoclistItems(a:buffer, a:loclist)
                            
                                " Build a map of current and new signs, with the lines as the keys.
    4   0.247669   0.000071     let l:sign_map = s:BuildSignMap(   a:buffer,   l:current_sign_list,   l:grouped_items,)
                            
    4   0.078155   0.000045     let l:command_list = ale#sign#GetSignCommands(   a:buffer,   l:is_dummy_sign_set,   l:sign_map,)
                            
                                " Change the sign column color if the option is on.
    4              0.000009     if g:ale_change_sign_column_color && !empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithErrors
                                endif
                            
    5              0.000011     for l:command in l:command_list
    1              0.002534         silent! execute l:command
    1              0.000010     endfor
                            
                                " Reset the sign column color when there are no more errors.
    4              0.000010     if g:ale_change_sign_column_color && empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithoutErrors
                                endif

FUNCTION  ale#cursor#EchoCursorWarningWithDelay()
Called 60 times
Total time:   0.010762
 Self time:   0.006179

count  total (s)   self (s)
   60              0.000297     if !g:ale_echo_cursor
                                    return
                                endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
   60              0.000512     if mode() isnot# 'n'
                                    return
                                endif
                            
   60   0.002488   0.000878     call s:StopCursorTimer()
                            
   60              0.000925     let l:pos = getcurpos()[0:2]
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should echo something. Otherwise we can end up doing processing
                                " the echo message far too frequently.
   60              0.000273     if l:pos != s:last_pos
   60   0.003918   0.000945         let l:delay = ale#Var(bufnr(''), 'echo_delay')
                            
   60              0.000255         let s:last_pos = l:pos
   60              0.000526         let s:cursor_timer = timer_start(   l:delay,   function('ale#cursor#EchoCursorWarning'))
   60              0.000077     endif

FUNCTION  <SNR>136_VimOutputCallback()
Called 2341 times
Total time:   0.080002
 Self time:   0.043070

count  total (s)   self (s)
 2341              0.004264     let l:job = ch_getjob(a:channel)
 2341   0.018472   0.009628     let l:job_id = ale#job#ParseVim8ProcessID(string(l:job))
                            
                                " Only call the callbacks for jobs which are valid.
 2341              0.005431     if l:job_id > 0 && has_key(s:job_map, l:job_id)
 2341   0.047868   0.019780         call ale#util#GetFunction(s:job_map[l:job_id].out_cb)(l:job_id, a:data)
 2341              0.001101     endif

FUNCTION  <SNR>143_StopCursorTimer()
Called 60 times
Total time:   0.001610
 Self time:   0.001610

count  total (s)   self (s)
   60              0.000257     if s:cursor_timer != -1
   60              0.000612         call timer_stop(s:cursor_timer)
   60              0.000345         let s:cursor_timer = -1
   60              0.000090     endif

FUNCTION  ale#sign#ReadSigns()
Called 4 times
Total time:   0.003575
 Self time:   0.003575

count  total (s)   self (s)
    4              0.000015     redir => l:output
    4              0.002077        silent execute 'sign place buffer=' . a:buffer
    4              0.000060     redir end
                            
    4              0.001418     return split(l:output, "\n")

FUNCTION  ale#job#Start()
Called 4 times
Total time:   0.004352
 Self time:   0.004163

count  total (s)   self (s)
    4   0.000053   0.000031     call ale#job#ValidateArguments(a:command, a:options)
                            
    4              0.000016     let l:job_info = copy(a:options)
    4              0.000006     let l:job_options = {}
                            
    4              0.000012     if has('nvim')
                                    if has_key(a:options, 'out_cb')
                                        let l:job_options.on_stdout = function('s:NeoVimCallback')
                                        let l:job_info.out_cb_line = ''
                                    endif
                            
                                    if has_key(a:options, 'err_cb')
                                        let l:job_options.on_stderr = function('s:NeoVimCallback')
                                        let l:job_info.err_cb_line = ''
                                    endif
                            
                                    if has_key(a:options, 'exit_cb')
                                        let l:job_options.on_exit = function('s:NeoVimCallback')
                                    endif
                            
                                    let l:job_info.job = jobstart(a:command, l:job_options)
                                    let l:job_id = l:job_info.job
                                else
    4              0.000017         let l:job_options = {   'in_mode': l:job_info.mode,   'out_mode': l:job_info.mode,   'err_mode': l:job_info.mode,}
                            
    4              0.000008         if has_key(a:options, 'out_cb')
    4              0.000018             let l:job_options.out_cb = function('s:VimOutputCallback')
    4              0.000001         endif
                            
    4              0.000007         if has_key(a:options, 'err_cb')
                                        let l:job_options.err_cb = function('s:VimErrorCallback')
                                    endif
                            
    4              0.000006         if has_key(a:options, 'exit_cb')
                                        " Set a close callback to which simply calls job_status()
                                        " when the channel is closed, which can trigger the exit callback
                                        " earlier on.
    4              0.000015             let l:job_options.close_cb = function('s:VimCloseCallback')
    4              0.000014             let l:job_options.exit_cb = function('s:VimExitCallback')
    4              0.000001         endif
                            
                                    " Vim 8 will read the stdin from the file's buffer.
    4              0.003574         let l:job_info.job = job_start(a:command, l:job_options)
    4   0.000373   0.000206         let l:job_id = ale#job#ParseVim8ProcessID(string(l:job_info.job))
    4              0.000009     endif
                            
    4              0.000006     if l:job_id > 0
                                    " Store the job in the map for later only if we can get the ID.
    4              0.000033         let s:job_map[l:job_id] = l:job_info
    4              0.000004     endif
                            
    4              0.000021     return l:job_id

FUNCTION  airline#extensions#ale#get_warning()
Called 179 times
Total time:   0.220585
 Self time:   0.001307

count  total (s)   self (s)
  179   0.220438   0.001160   return airline#extensions#ale#get('warning')

FUNCTION  <SNR>68_GetCommandPrefix()
Called 1 time
Total time:   0.000277
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000007         if exists("g:wakatime_OverrideCommandPrefix") && g:wakatime_OverrideCommandPrefix
                                        let prefix = [g:wakatime_OverrideCommandPrefix]
                                    else
    1   0.000260   0.000012             let python_bin = s:GetPythonBinary()
    1              0.000004             let prefix = [python_bin, '-W', 'ignore', s:cli_location]
    1              0.000001         endif
    1              0.000001         return prefix

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    4   1.097600   0.001481  <SNR>136_VimCloseCallback()
    7   1.095596   0.001249  <SNR>131_HandleExit()
    4   1.022906   0.018473  ale#engine#HandleLoclist()
    4   0.798012   0.006750  ale#engine#SetResults()
    4   0.590564   0.000342  <SNR>136_VimExitCallback()
    4   0.507731   0.003617  ale#sign#SetSigns()
    4   0.291669   0.094467  <SNR>97_find_opening_paren()
    4   0.247598   0.140248  <SNR>147_BuildSignMap()
  358   0.232703   0.029401  airline#extensions#ale#get()
  179   0.220585   0.001307  airline#extensions#ale#get_warning()
    4   0.211292   0.007296  <SNR>148_SetListsImpl()
    4   0.203592   0.065702  <SNR>148_FixList()
  358   0.192840   0.191535  <SNR>109_airline_ale_get_line_number()
  179   0.179945   0.014767  airline#check_mode()
    5   0.162926   0.021453  airline#highlighter#highlight()
 9552   0.149715             ale#util#LocItemCompare()
    1   0.148893   0.000266  GetPythonPEPIndent()
    4   0.148415   0.004090  ale#highlight#SetHighlights()
    4   0.144325   0.106306  ale#highlight#UpdateHighlights()
 3117   0.137807             ale#GetLocItemMessage()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
  358   0.192840   0.191535  <SNR>109_airline_ale_get_line_number()
 9552              0.149715  ale#util#LocItemCompare()
    4   0.247598   0.140248  <SNR>147_BuildSignMap()
 3117              0.137807  ale#GetLocItemMessage()
    4   0.144325   0.106306  ale#highlight#UpdateHighlights()
    4              0.098050  ale#sign#ParseSigns()
    4   0.291669   0.094467  <SNR>97_find_opening_paren()
    4              0.078110  ale#sign#GetSignCommands()
 3117   0.107227   0.074552  ale#sign#GetSignName()
    4   0.203592   0.065702  <SNR>148_FixList()
   45   0.070877   0.063825  <SNR>142_InvokeCompletion()
    4              0.054712  ale#util#GetMatches()
    4   0.056292   0.054673  ale#engine#FixLocList()
  192              0.052008  <SNR>97_is_concealed()
    1              0.046922  <SNR>92_FormatCurrentLine()
    4              0.044127  <SNR>147_UpdateLineNumbers()
  258              0.043562  <SNR>142_Pyeval()
 2341   0.080002   0.043070  <SNR>136_VimOutputCallback()
    4   0.041883   0.041855  ale#statusline#Update()
  440   0.123002   0.039334  airline#highlighter#exec()

